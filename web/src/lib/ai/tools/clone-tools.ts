/**
 * AI Clone Tools - Function Calling Schemas
 *
 * Implements tool schemas for LLM function calling using Vercel AI SDK format.
 * Each tool follows the 6-dimension ontology and integrates with the backend.
 *
 * Tools available:
 * - search_knowledge: Search clone's knowledge base (RAG)
 * - create_content: Generate content based on clone's training
 * - schedule_meeting: Book meetings with creator's calendar
 * - send_email: Send email to user on behalf of creator
 * - check_calendar: Check creator's availability
 * - access_course: Retrieve course content
 * - recommend_product: Recommend products to users
 */

import { tool } from 'ai';
import { z } from 'zod';

/**
 * Tool: search_knowledge
 *
 * Searches the clone's knowledge base using semantic search (RAG).
 * Returns relevant chunks of knowledge from the creator's training data.
 *
 * Dimension mapping:
 * - Knowledge: Uses vector search
 * - Things: Sources content from things (courses, blog posts, etc.)
 * - Events: Logs search_performed event
 */
export const searchKnowledgeTool = tool({
  description: `Search the AI clone's knowledge base for information. Use this when the user asks about topics the creator has written about or taught. Returns semantically relevant content from courses, blog posts, videos, and other training sources.`,

  parameters: z.object({
    query: z.string().describe('The search query to find relevant knowledge'),
    limit: z.number()
      .optional()
      .default(5)
      .describe('Maximum number of results to return (1-20)'),
    minRelevance: z.number()
      .optional()
      .default(0.7)
      .describe('Minimum relevance score (0-1)'),
  }),

  execute: async ({ query, limit, minRelevance }) => {
    // This is a placeholder - actual implementation will call Convex mutation
    // The mutation will handle the vector search and return results
    return {
      success: true,
      query,
      limit,
      minRelevance,
      // Results will be populated by backend
      results: [],
    };
  },
});

/**
 * Tool: create_content
 *
 * Generates content in the creator's style using the clone's training.
 * Can create blog posts, social media posts, email drafts, etc.
 *
 * Dimension mapping:
 * - Things: Creates new thing (type: blog_post, social_post, etc.)
 * - Connections: Links to creator (created_by)
 * - Events: Logs content_generated event
 */
export const createContentTool = tool({
  description: `Generate content in the creator's style. Use this when the user requests content creation like blog posts, social media posts, or email drafts. The clone will write in the creator's voice based on training data.`,

  parameters: z.object({
    type: z.enum([
      'blog_post',
      'social_post',
      'email_draft',
      'lesson_outline',
      'product_description'
    ]).describe('Type of content to create'),

    title: z.string().describe('Title or subject of the content'),

    outline: z.array(z.string())
      .optional()
      .describe('Key points or sections to cover'),

    tone: z.enum(['professional', 'casual', 'educational', 'promotional'])
      .optional()
      .default('professional')
      .describe('Tone of voice for the content'),

    length: z.enum(['short', 'medium', 'long'])
      .optional()
      .default('medium')
      .describe('Approximate length of content'),
  }),

  execute: async ({ type, title, outline, tone, length }) => {
    // Backend will generate content using clone's system prompt and training
    return {
      success: true,
      type,
      title,
      outline,
      tone,
      length,
      // Content will be generated by backend
      content: '',
      wordCount: 0,
    };
  },
});

/**
 * Tool: schedule_meeting
 *
 * Books a meeting with the creator's calendar.
 * Checks availability and creates calendar events.
 *
 * Dimension mapping:
 * - Things: Creates meeting thing
 * - Connections: Links attendees to meeting
 * - Events: Logs meeting_scheduled event
 */
export const scheduleMeetingTool = tool({
  description: `Schedule a meeting with the creator. Use this when users want to book time with the creator. Checks calendar availability and creates the meeting.`,

  parameters: z.object({
    datetime: z.string().describe('Requested date and time (ISO 8601 format)'),

    duration: z.number()
      .min(15)
      .max(240)
      .default(30)
      .describe('Meeting duration in minutes'),

    attendees: z.array(z.string().email())
      .describe('Email addresses of attendees'),

    subject: z.string().describe('Meeting subject/title'),

    description: z.string()
      .optional()
      .describe('Additional meeting details'),

    meetingType: z.enum(['video', 'phone', 'in-person'])
      .optional()
      .default('video')
      .describe('Type of meeting'),
  }),

  execute: async ({ datetime, duration, attendees, subject, description, meetingType }) => {
    // Backend will check calendar and create meeting
    return {
      success: false, // Will be true if meeting is booked
      datetime,
      duration,
      attendees,
      subject,
      description,
      meetingType,
      // Backend fills these in:
      meetingId: '',
      calendarLink: '',
      available: false,
    };
  },
});

/**
 * Tool: send_email
 *
 * Sends an email to the user on behalf of the creator.
 * Requires approval settings per clone.
 *
 * Dimension mapping:
 * - Events: Logs email_sent event
 * - Connections: Creates communicated relationship
 * - People: Actor is clone (on behalf of creator)
 */
export const sendEmailTool = tool({
  description: `Send an email to the user on behalf of the creator. Use this for follow-ups, sharing resources, or responding to inquiries. May require creator approval depending on settings.`,

  parameters: z.object({
    to: z.string().email().describe('Recipient email address'),

    subject: z.string().describe('Email subject line'),

    body: z.string().describe('Email body content (plain text or HTML)'),

    cc: z.array(z.string().email())
      .optional()
      .describe('CC recipients'),

    bcc: z.array(z.string().email())
      .optional()
      .describe('BCC recipients'),

    attachments: z.array(z.object({
      name: z.string(),
      url: z.string(),
      mimeType: z.string(),
    }))
      .optional()
      .describe('Email attachments'),

    priority: z.enum(['low', 'normal', 'high'])
      .optional()
      .default('normal')
      .describe('Email priority'),
  }),

  execute: async ({ to, subject, body, cc, bcc, attachments, priority }) => {
    // Backend will send email (may require approval)
    return {
      success: false,
      to,
      subject,
      body,
      cc,
      bcc,
      attachments,
      priority,
      // Backend fills these in:
      emailId: '',
      status: 'pending_approval', // or 'sent', 'failed'
      sentAt: 0,
    };
  },
});

/**
 * Tool: check_calendar
 *
 * Checks the creator's calendar availability.
 * Useful before scheduling meetings.
 *
 * Dimension mapping:
 * - Things: Queries calendar things
 * - Events: Logs calendar_checked event
 */
export const checkCalendarTool = tool({
  description: `Check the creator's calendar availability. Use this to see when the creator is free for meetings or events.`,

  parameters: z.object({
    date: z.string().describe('Date to check (YYYY-MM-DD format)'),

    startTime: z.string()
      .optional()
      .describe('Start time (HH:MM format)'),

    endTime: z.string()
      .optional()
      .describe('End time (HH:MM format)'),

    timezone: z.string()
      .optional()
      .default('UTC')
      .describe('Timezone for the query'),
  }),

  execute: async ({ date, startTime, endTime, timezone }) => {
    // Backend will query calendar
    return {
      success: true,
      date,
      startTime,
      endTime,
      timezone,
      // Backend fills these in:
      available: false,
      busySlots: [],
      freeSlots: [],
    };
  },
});

/**
 * Tool: access_course
 *
 * Retrieves course content for enrolled users.
 * Checks enrollment and returns lesson content.
 *
 * Dimension mapping:
 * - Things: Accesses course and lesson things
 * - Connections: Checks enrolled_in connection
 * - Events: Logs course_accessed event
 */
export const accessCourseTool = tool({
  description: `Retrieve course content for enrolled users. Use this when users ask about course materials, lessons, or curriculum. Checks enrollment status first.`,

  parameters: z.object({
    courseId: z.string().describe('ID of the course to access'),

    section: z.string()
      .optional()
      .describe('Specific section or lesson to retrieve'),

    format: z.enum(['summary', 'full', 'outline'])
      .optional()
      .default('summary')
      .describe('Level of detail to return'),
  }),

  execute: async ({ courseId, section, format }) => {
    // Backend will check enrollment and return content
    return {
      success: false,
      courseId,
      section,
      format,
      // Backend fills these in:
      enrolled: false,
      courseName: '',
      content: '',
      lessons: [],
      nextLesson: '',
    };
  },
});

/**
 * Tool: recommend_product
 *
 * Recommends products to users based on their needs and budget.
 * Uses creator's product catalog and knowledge graph.
 *
 * Dimension mapping:
 * - Things: Queries product things
 * - Knowledge: Uses embeddings for semantic matching
 * - Events: Logs product_recommended event
 */
export const recommendProductTool = tool({
  description: `Recommend products to users based on their needs and budget. Use this when users ask for product suggestions or need help choosing between options.`,

  parameters: z.object({
    category: z.string()
      .optional()
      .describe('Product category to filter (e.g., "course", "membership", "book")'),

    budget: z.object({
      min: z.number().optional(),
      max: z.number().optional(),
      currency: z.string().default('USD'),
    })
      .optional()
      .describe('User\'s budget range'),

    needs: z.array(z.string())
      .optional()
      .describe('User\'s specific needs or goals'),

    level: z.enum(['beginner', 'intermediate', 'advanced'])
      .optional()
      .describe('User\'s skill level'),

    limit: z.number()
      .optional()
      .default(3)
      .describe('Maximum number of recommendations (1-10)'),
  }),

  execute: async ({ category, budget, needs, level, limit }) => {
    // Backend will query products and use semantic search
    return {
      success: true,
      category,
      budget,
      needs,
      level,
      limit,
      // Backend fills these in:
      recommendations: [],
      reasoning: [],
    };
  },
});

/**
 * All tools registry
 *
 * Export all tools as a single object for easy import
 */
export const cloneTools = {
  search_knowledge: searchKnowledgeTool,
  create_content: createContentTool,
  schedule_meeting: scheduleMeetingTool,
  send_email: sendEmailTool,
  check_calendar: checkCalendarTool,
  access_course: accessCourseTool,
  recommend_product: recommendProductTool,
} as const;

/**
 * Tool names as type-safe array
 */
export const toolNames = Object.keys(cloneTools) as Array<keyof typeof cloneTools>;

/**
 * Tool metadata for UI display
 */
export const toolMetadata = {
  search_knowledge: {
    name: 'Search Knowledge',
    description: 'Search the clone\'s knowledge base',
    category: 'knowledge',
    requiresApproval: false,
    rateLimitPerHour: 100,
    icon: 'search',
  },
  create_content: {
    name: 'Create Content',
    description: 'Generate content in creator\'s style',
    category: 'generation',
    requiresApproval: true,
    rateLimitPerHour: 20,
    icon: 'edit',
  },
  schedule_meeting: {
    name: 'Schedule Meeting',
    description: 'Book meetings with creator',
    category: 'calendar',
    requiresApproval: true,
    rateLimitPerHour: 10,
    icon: 'calendar',
  },
  send_email: {
    name: 'Send Email',
    description: 'Send emails on behalf of creator',
    category: 'communication',
    requiresApproval: true,
    rateLimitPerHour: 5,
    icon: 'mail',
  },
  check_calendar: {
    name: 'Check Calendar',
    description: 'View calendar availability',
    category: 'calendar',
    requiresApproval: false,
    rateLimitPerHour: 50,
    icon: 'calendar-check',
  },
  access_course: {
    name: 'Access Course',
    description: 'Retrieve course content',
    category: 'education',
    requiresApproval: false,
    rateLimitPerHour: 30,
    icon: 'book-open',
  },
  recommend_product: {
    name: 'Recommend Product',
    description: 'Suggest products to users',
    category: 'commerce',
    requiresApproval: false,
    rateLimitPerHour: 40,
    icon: 'shopping-bag',
  },
} as const;

/**
 * Type exports for TypeScript
 */
export type CloneToolName = keyof typeof cloneTools;
export type CloneToolMetadata = typeof toolMetadata[CloneToolName];
export type CloneToolCategory = 'knowledge' | 'generation' | 'calendar' | 'communication' | 'education' | 'commerce';
