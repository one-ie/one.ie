---
export const prerender = true;

import Layout from '../../layouts/Layout.astro';
import { getCollection } from 'astro:content';
import type { CollectionEntry } from 'astro:content';
import { DocSearch } from '@/components/docs/DocSearch';
import { DocViewToggle } from '@/components/docs/DocViewToggle';
import { DocList } from '@/components/docs/DocList';
import { DocGrid } from '@/components/docs/DocGrid';
import { DocCompact } from '@/components/docs/DocCompact';
import { DocFolderNav } from '@/components/docs/DocFolderNav';
import { DocFilterResults } from '@/components/docs/DocFilterResults';
import { FileText } from 'lucide-react';

type DocEntry = CollectionEntry<'docs'>;
type DocFolder = Record<string, DocEntry[]>;

// Get view preference from URL or default to list view
const viewMode = (Astro.url.searchParams.get('view') || 'list') as
  | 'list'
  | 'compact'
  | 'grid2'
  | 'grid3'
  | 'grid4';

// Get all docs entries
const entries = (await getCollection('docs')) as DocEntry[];

// Get search query from URL
const searchQuery = Astro.url.searchParams.get('search')?.toLowerCase() || '';

// Get tag filter from URL
const tagFilter = Astro.url.searchParams.get('tag')?.toLowerCase() || '';

// Get folder filter from URL
const folderFilter = Astro.url.searchParams.get('folder')?.toLowerCase() || '';

// Filter entries by search query, tag, or folder
const filteredEntries = searchQuery || tagFilter || folderFilter
  ? entries.filter((entry: DocEntry) => {
      const title = entry.data.title?.toLowerCase() || '';
      const description = entry.data.description?.toLowerCase() || '';
      const section = entry.data.section?.toLowerCase() || '';
      const tags = entry.data.tags?.map((t: string) => t.toLowerCase()) || [];
      const folderPath = entry.slug.split('/')[0].toLowerCase();

      // If folder filter is present, it takes precedence
      if (folderFilter) {
        return folderPath === folderFilter;
      }

      // If tag filter is present, it takes precedence over search
      if (tagFilter) {
        return tags.includes(tagFilter);
      }

      // Otherwise use search query
      return (
        title.includes(searchQuery) ||
        description.includes(searchQuery) ||
        section.includes(searchQuery) ||
        tags.some((tag: string) => tag.includes(searchQuery))
      );
    })
  : entries;

// Group by folders (first level of path)
const folders = filteredEntries.reduce((acc: DocFolder, entry: DocEntry) => {
  // Extract the folder name from the slug (first part before slash, or 'root' if no slash)
  const folderPath = entry.slug.includes('/') ? entry.slug.split('/')[0] : 'root';

  if (!acc[folderPath]) {
    acc[folderPath] = [];
  }
  acc[folderPath].push(entry);
  return acc;
}, {});

// Sort folders alphabetically with 'root' at the top
const orderedFolders = Object.entries(folders)
  .sort(([a, _a]: [string, DocEntry[]], [b, _b]: [string, DocEntry[]]) => {
    if (a === 'root') return -1;
    if (b === 'root') return 1;
    return a.localeCompare(b);
  })
  .reduce((acc, [key, value]) => ({ ...acc, [key]: value }), {}) as Record<
  string,
  DocEntry[]
>;

// Get appropriate icon based on folder name
function getFolderIcon(folder: string) {
  const iconMap: Record<string, string> = {
    'getting-started': 'ðŸš€',
    'core-concepts': 'ðŸ—ï¸',
    advanced: 'âš¡',
    'ai-sdk': 'âš¡',
    tutorials: 'ðŸ“š',
    troubleshooting: 'â„¹ï¸',
  };
  return iconMap[folder.toLowerCase()] || 'ðŸ“';
}

// Format folder name for display
function formatFolderName(folder: string): string {
  if (folder === 'root') return 'Get Started';

  // Replace hyphens with spaces and capitalize each word
  return folder
    .replace(/-/g, ' ')
    .split(' ')
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ');
}

// Get folder counts for navigation
const folderCounts = Object.entries(orderedFolders).reduce(
  (acc, [folder, entries]) => {
    acc[folder] = entries.length;
    return acc;
  },
  {} as Record<string, number>
);
---

<Layout title="Documentation - ONE" description="Learn how to use and extend the ONE Platform">
  <div class="max-w-full px-3 sm:px-4 pt-4 pb-8">
    {/* Header with Search and View Toggles */}
    <div class="flex flex-col md:flex-row justify-between items-start md:items-center gap-3 mb-4">
      <div>
        <h1 class="text-3xl md:text-4xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-primary to-primary/70">
          Documentation
        </h1>
        <p class="text-base text-muted-foreground mt-1">
          Everything you need to understand the ONE Platform
        </p>
      </div>

      <div class="flex flex-col sm:flex-row gap-2 w-full md:w-auto">
        <DocSearch client:load value={searchQuery} viewMode={viewMode} folderFilter={folderFilter} tagFilter={tagFilter} />
        <DocViewToggle
          client:load
          currentView={viewMode}
          onViewChange={() => {}}
          preserveParams={{
            search: searchQuery,
            tag: tagFilter,
            folder: folderFilter,
          }}
        />
      </div>
    </div>

    {/* Filter Results */}
    <DocFilterResults
      searchQuery={searchQuery}
      tagFilter={tagFilter}
      folderFilter={folderFilter}
      resultCount={filteredEntries.length}
    />

    {/* All Folders Navigation */}
    {!searchQuery && !tagFilter && !folderFilter && (
      <DocFolderNav folders={folderCounts} currentFolder={folderFilter} />
    )}

    {/* Documentation Folders */}
    {filteredEntries.length > 0 ? (
      <div class="space-y-6">
        {(Object.entries(orderedFolders) as Array<[string, DocEntry[]]>).map(
          ([folder, folderEntries]) =>
            folderEntries.length > 0 && (
              <div class="mb-6">
                <div class="flex items-center gap-2 mb-3 pb-1 border-b border-border/40">
                  <div class="text-2xl">{getFolderIcon(folder)}</div>

                  <div class="flex flex-wrap items-center gap-2">
                    <h2 class="text-lg font-bold text-foreground">
                      {formatFolderName(folder)}
                    </h2>
                    <span
                      class="bg-primary/10 text-primary text-xs px-2 py-1 rounded"
                    >
                      {folderEntries.length}
                    </span>
                    {!folderFilter && (
                      <a
                        href={`/docs?folder=${encodeURIComponent(folder)}`}
                        class="text-primary hover:underline text-base"
                      >
                        View all
                      </a>
                    )}
                  </div>
                </div>

                {/* Grid 4 View - No descriptions, 4 columns */}
                {viewMode === 'grid4' && (
                  <DocGrid
                    client:load
                    entries={folderEntries}
                    columns={4}
                    showDescription={false}
                  />
                )}

                {/* Compact View - Table-like format */}
                {viewMode === 'compact' && (
                  <DocCompact client:load entries={folderEntries} />
                )}

                {/* Standard Grid Views */}
                {(viewMode === 'grid2' || viewMode === 'grid3') && (
                  <DocGrid
                    client:load
                    entries={folderEntries}
                    columns={viewMode === 'grid3' ? 3 : 2}
                    showDescription={true}
                  />
                )}

                {/* List View - Optimized */}
                {viewMode === 'list' && (
                  <DocList client:load entries={folderEntries} />
                )}
              </div>
            )
        )}
      </div>
    ) : (
      /* Empty State */
      <div class="text-center py-8 bg-muted/20 rounded-lg mt-4">
        <div class="max-w-md mx-auto">
          <FileText className="w-12 h-12 text-muted-foreground mx-auto mb-4 opacity-50" />
          <h2 class="text-xl font-semibold mb-2">
            {searchQuery
              ? 'No matching documents found'
              : tagFilter
                ? 'No documents with this tag'
                : folderFilter
                  ? 'No documents in this folder'
                  : 'No documentation found'}
          </h2>
          <p class="text-base text-muted-foreground">
            {searchQuery
              ? `No documentation pages match your search for "${searchQuery}".`
              : tagFilter
                ? `No documentation pages found with tag "${tagFilter}".`
                : folderFilter
                  ? `No documentation pages found in folder "${formatFolderName(folderFilter)}".`
                  : 'No documentation pages exist in the content collection.'}
          </p>
          {(searchQuery || tagFilter || folderFilter) && (
            <a href="/docs" class="inline-block mt-3 text-primary hover:underline text-base">
              View all documentation
            </a>
          )}
        </div>
      </div>
    )}
  </div>

  <style>
    :global(body) {
      background-image:
        radial-gradient(
          at 100% 0%,
          hsla(var(--primary-hsl) / 0.15) 0px,
          transparent 50%
        ),
        radial-gradient(
          at 0% 100%,
          hsla(var(--primary-hsl) / 0.1) 0px,
          transparent 50%
        );
      background-attachment: fixed;
    }

    a {
      text-decoration: none !important;
    }
  </style>
</Layout>
