# AI Website Builder - Schema Design Summary

## Overview

This schema implements the AI Website Builder using the 6-dimension ontology. **NO custom tables** - everything maps to the existing 5 core tables.

## File Location

`/home/user/one.ie/web/convex/schema.ts`

## New Entity Types Added (4)

1. **website** - Websites created by users
2. **page** - Pages within websites (Astro code)
3. **ai_conversation** - AI chat conversations for page generation
4. **deployment** - Cloudflare deployments
5. **component** - Reusable UI components (global)

## New Connection Types (2)

1. **contains** - Website contains pages
2. **modified** - AI assistant modified page

## New Event Types (9)

1. **website_created** - Website created
2. **page_generated** - Page generated by AI
3. **page_modified** - Page modified by AI or user
4. **deployment_started** - Deployment to Cloudflare started
5. **deployment_completed** - Deployment completed
6. **deployment_failed** - Deployment failed
7. **ai_page_generated** - AI generated page (detailed)
8. **component_searched** - Component search query
9. **domain_configured** - Custom domain configured

## 6-Dimension Mapping

### 1. GROUPS (Multi-tenant Isolation)

Added to limits/usage:
- `websites: number` - Websites per group
- `pages: number` - Total pages across all websites
- `aiMessages: number` - AI usage quota
- `deployments: number` - Deployment count
- `storage: number` - Total storage

### 2. PEOPLE (Authorization)

Roles: `platform_owner`, `org_owner`, `org_user`, `customer`

Permissions: `websites.create`, `pages.edit`, `deployments.deploy`

### 3. THINGS (Entities)

All website builder entities stored in `entities` table with different `type` values.

Example Website:
```typescript
{
  _id: "website123",
  type: "website",
  name: "Acme Landing Page",
  groupId: "group123",
  properties: {
    domain: "acme.pages.dev",
    settings: { title, description, favicon, analytics },
    cloudflare: { projectId, accountId }
  },
  status: "live"
}
```

Example Page:
```typescript
{
  _id: "page123",
  type: "page",
  name: "Home Page",
  groupId: "group123",
  properties: {
    websiteId: "website123",
    slug: "/",
    code: "<Layout>...</Layout>",
    compiledHtml: "<html>...</html>",
    metadata: { description, keywords, ogImage }
  },
  status: "published"
}
```

### 4. CONNECTIONS (Relationships)

- `owns` - Creator owns website
- `contains` - Website contains pages
- `modified` - AI modified page

### 5. EVENTS (Audit Trail)

Every action logged: website_created, page_generated, deployment_completed, etc.

### 6. KNOWLEDGE (Semantic Search)

Component library with vector embeddings:
```typescript
{
  knowledgeType: "chunk",
  text: "Centered hero section with CTA...",
  embedding: [0.123, -0.456, ...], // 3072 dimensions
  sourceEntityId: "comp123",
  metadata: {
    category: "hero",
    code: "<section>...</section>",
    preview: "https://..."
  }
}
```

## Key Indexes

- `by_group_type` - List entities by group and type
- `by_status` - Filter by status
- `from_type` / `to_type` - Relationship traversal
- `by_embedding` - Vector search for components
- `search_entities` - Full-text search

## Example Queries

### List websites for a group
```typescript
const websites = await ctx.db
  .query("entities")
  .withIndex("by_group_type", q =>
    q.eq("groupId", groupId).eq("type", "website")
  )
  .collect();
```

### Get pages for a website
```typescript
const connections = await ctx.db
  .query("connections")
  .withIndex("from_type", q =>
    q.eq("fromEntityId", websiteId).eq("relationshipType", "contains")
  )
  .collect();

const pages = await Promise.all(
  connections.map(c => ctx.db.get(c.toEntityId))
);
```

### Search components semantically
```typescript
const components = await ctx.db
  .vectorSearch("knowledge", "by_embedding", {
    vector: embedUserQuery("pricing table"),
    limit: 10,
    filter: q => q.eq("knowledgeType", "chunk")
  });
```

## Validation Pattern

Every mutation MUST:
1. Authenticate (get user identity)
2. Authorize (check role and permissions)
3. Validate group (exists and active)
4. Enforce limits (usage < limits)
5. Create entity
6. Create connections
7. Log event
8. Update usage

## Next Steps

- **Cycle 2:** Create mutations (websites, pages, deployments)
- **Cycle 3:** Create queries (list, get, filter)
- **Cycle 4:** Build Effect.ts services
- **Cycle 5:** Generate component embeddings

## Design Principles

1. **Pattern Convergence:** ONE way to store entities (not 100)
2. **No Schema Migrations:** Add types, not tables
3. **Multi-tenant Isolation:** Every entity has groupId
4. **Complete Audit Trail:** Every action logged
5. **Semantic Search:** Components searchable via embeddings

## Success Criteria

- [x] Schema follows 6-dimension ontology
- [x] All entity types from defined types
- [x] Connection types from defined types
- [x] Event types from defined types
- [x] Proper indexes for all queries
- [x] Multi-tenant isolation via groupId
- [x] Resource quotas in groups table
- [ ] Mutations implemented (Cycle 2)
- [ ] Queries implemented (Cycle 3)
- [ ] Tests passing (Cycle 6)
