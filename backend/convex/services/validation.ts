/**
 * SEMANTIC VALIDATION SERVICE
 *
 * Defines semantic rules for all 25 connection types from the ontology.
 * Validates that connections make sense based on thing types.
 *
 * Pattern: Each relationship type has:
 * - validFromTypes: Thing types allowed as source
 * - validToTypes: Thing types allowed as target
 * - allowsCycles: Whether A→B→A is valid
 * - description: What this relationship means
 *
 * Usage:
 *   const result = validateConnection("creator", "token", "owns");
 *   if (!result.success) throw new Error(result.reason);
 */

export interface RelationshipRule {
  validFromTypes: string[];
  validToTypes: string[];
  allowsCycles?: boolean;
  description: string;
}

export type ValidationResult =
  | { success: true }
  | { success: false; reason: string };

/**
 * Relationship rules for all 25 connection types
 * Maps each relationshipType to validation constraints
 */
export const RelationshipRules: Record<string, RelationshipRule> = {
  // OWNERSHIP (2 types)
  owns: {
    validFromTypes: ["creator", "organization", "group", "ai_clone"],
    validToTypes: ["*"],
    description: "Creator/Org/Group owns any entity"
  },
  created_by: {
    validFromTypes: ["*"],
    validToTypes: ["creator", "ai_clone", "strategy_agent", "marketing_agent", "engineering_agent"],
    description: "Entity was created by a person or agent"
  },

  // AI RELATIONSHIPS (3 types)
  clone_of: {
    validFromTypes: ["ai_clone"],
    validToTypes: ["creator"],
    allowsCycles: false,
    description: "AI clone is a copy of a creator"
  },
  trained_on: {
    validFromTypes: ["ai_clone", "strategy_agent", "marketing_agent", "sales_agent", "intelligence_agent"],
    validToTypes: ["knowledge_item", "blog_post", "video", "podcast", "course", "document"],
    description: "Agent trained on content/knowledge"
  },
  powers: {
    validFromTypes: ["strategy_agent", "marketing_agent", "sales_agent", "engineering_agent", "service_agent"],
    validToTypes: ["ai_clone", "website", "email_campaign", "social_post"],
    description: "Agent powers/operates an entity"
  },

  // CONTENT RELATIONSHIPS (5 types)
  authored: {
    validFromTypes: ["creator", "audience_member"],
    validToTypes: ["blog_post", "video", "podcast", "social_post", "email", "course", "newsletter"],
    description: "Person authored content"
  },
  generated_by: {
    validFromTypes: ["*"],
    validToTypes: ["ai_clone", "strategy_agent", "marketing_agent"],
    description: "Content was generated by an AI"
  },
  published_to: {
    validFromTypes: ["blog_post", "video", "podcast", "social_post"],
    validToTypes: ["website", "community", "email_campaign"],
    description: "Content published to channel"
  },
  part_of: {
    validFromTypes: ["*"],
    validToTypes: ["*"],
    allowsCycles: false,
    description: "Entity is part of another (prevents cycles)"
  },
  references: {
    validFromTypes: ["blog_post", "video", "podcast", "course", "lesson"],
    validToTypes: ["blog_post", "video", "token", "external_agent", "knowledge_item"],
    description: "Content references another entity"
  },

  // COMMUNITY RELATIONSHIPS (4 types)
  member_of: {
    validFromTypes: ["creator", "audience_member"],
    validToTypes: ["group", "organization", "community"],
    allowsCycles: false,
    description: "Person is member of group (metadata.role = group_owner|group_user)"
  },
  following: {
    validFromTypes: ["creator", "audience_member"],
    validToTypes: ["creator", "community", "ai_clone"],
    description: "Person follows creator/community"
  },
  moderates: {
    validFromTypes: ["creator"],
    validToTypes: ["community", "conversation"],
    description: "Creator moderates a community/conversation"
  },
  participated_in: {
    validFromTypes: ["creator", "audience_member"],
    validToTypes: ["conversation", "livestream", "event"],
    description: "Person participated in discussion/event"
  },

  // BUSINESS RELATIONSHIPS (3 types)
  manages: {
    validFromTypes: ["creator"],
    validToTypes: ["organization", "team", "project"],
    description: "Creator manages organization/team"
  },
  reports_to: {
    validFromTypes: ["creator"],
    validToTypes: ["creator"],
    allowsCycles: false,
    description: "Creator reports to another (chain of command)"
  },
  collaborates_with: {
    validFromTypes: ["creator", "organization"],
    validToTypes: ["creator", "organization"],
    description: "Creator/org collaborates with other"
  },

  // TOKEN RELATIONSHIPS (3 types)
  holds_tokens: {
    validFromTypes: ["creator", "audience_member", "organization"],
    validToTypes: ["token"],
    description: "Entity holds/owns tokens (metadata.balance)"
  },
  staked_in: {
    validFromTypes: ["creator", "audience_member"],
    validToTypes: ["token", "token_contract"],
    description: "Tokens staked in contract"
  },
  earned_from: {
    validFromTypes: ["creator", "audience_member"],
    validToTypes: ["token", "course", "task"],
    description: "Tokens earned from activity"
  },

  // PRODUCT RELATIONSHIPS (4 types)
  purchased: {
    validFromTypes: ["creator", "audience_member"],
    validToTypes: ["digital_product", "membership", "course", "nft", "token"],
    description: "Person purchased product (metadata.transactionId)"
  },
  enrolled_in: {
    validFromTypes: ["creator", "audience_member"],
    validToTypes: ["course"],
    allowsCycles: false,
    description: "Person enrolled in course (metadata.progress)"
  },
  completed: {
    validFromTypes: ["creator", "audience_member"],
    validToTypes: ["course", "lesson"],
    description: "Person completed course/lesson"
  },
  teaching: {
    validFromTypes: ["creator", "ai_clone"],
    validToTypes: ["course"],
    description: "Creator/AI teaches a course"
  },

  // CONSOLIDATED TYPES (7 types) - Use metadata for variants
  transacted: {
    validFromTypes: ["*"],
    validToTypes: ["*"],
    description: "Financial transaction (metadata.transactionType: payment|subscription|invoice)"
  },
  notified: {
    validFromTypes: ["creator", "audience_member"],
    validToTypes: ["notification", "email_campaign"],
    description: "Person notified (metadata.channel: email|sms|push|in_app)"
  },
  referred: {
    validFromTypes: ["creator", "audience_member"],
    validToTypes: ["creator"],
    description: "Person was referred by another (metadata.referralCode)"
  },
  communicated: {
    validFromTypes: ["*"],
    validToTypes: ["*"],
    description: "Agent/protocol communication (metadata.protocol: a2a|acp|ag-ui)"
  },
  delegated: {
    validFromTypes: ["creator", "strategy_agent"],
    validToTypes: ["*"],
    description: "Task delegated (metadata.taskId, protocol)"
  },
  approved: {
    validFromTypes: ["creator"],
    validToTypes: ["*"],
    description: "Entity approved (metadata.approvalType, protocol)"
  },
  fulfilled: {
    validFromTypes: ["*"],
    validToTypes: ["*"],
    description: "Request fulfilled (metadata.fulfillmentType, protocol)"
  },
};

/**
 * Validate a connection between two thing types
 *
 * @param fromType - Thing type of source entity
 * @param toType - Thing type of target entity
 * @param relationshipType - Type of relationship
 * @returns { success: true } or { success: false, reason: string }
 */
export function validateConnection(
  fromType: string,
  toType: string,
  relationshipType: string
): ValidationResult {
  // Check relationship type exists
  const rule = RelationshipRules[relationshipType];
  if (!rule) {
    return {
      success: false,
      reason: `Unknown relationship type: ${relationshipType}`
    };
  }

  // Check FROM type is valid
  const validFromTypes = rule.validFromTypes;
  if (!validFromTypes.includes("*") && !validFromTypes.includes(fromType)) {
    return {
      success: false,
      reason: `${relationshipType} cannot start from ${fromType}. Valid sources: ${validFromTypes.join(", ")}`
    };
  }

  // Check TO type is valid
  const validToTypes = rule.validToTypes;
  if (!validToTypes.includes("*") && !validToTypes.includes(toType)) {
    return {
      success: false,
      reason: `${relationshipType} cannot end at ${toType}. Valid targets: ${validToTypes.join(", ")}`
    };
  }

  // Check cycles
  if (!rule.allowsCycles && fromType === toType) {
    return {
      success: false,
      reason: `${relationshipType} does not allow cycles (cannot connect ${fromType} to itself)`
    };
  }

  return { success: true };
}

/**
 * Get all possible thing types for a relationship direction
 *
 * Useful for building UI dropdowns showing "what can I connect to this?"
 */
export function getValidTargetTypes(relationshipType: string): string[] {
  const rule = RelationshipRules[relationshipType];
  if (!rule) return [];

  return rule.validToTypes.includes("*")
    ? ["*"] // Return wildcard indicator
    : rule.validToTypes;
}

export function getValidSourceTypes(relationshipType: string): string[] {
  const rule = RelationshipRules[relationshipType];
  if (!rule) return [];

  return rule.validFromTypes.includes("*")
    ? ["*"] // Return wildcard indicator
    : rule.validFromTypes;
}

/**
 * Get description of a relationship type
 */
export function getRelationshipDescription(relationshipType: string): string {
  const rule = RelationshipRules[relationshipType];
  return rule?.description || "Unknown relationship";
}

/**
 * Check if a relationship allows self-references
 */
export function allowsSelfReference(relationshipType: string): boolean {
  const rule = RelationshipRules[relationshipType];
  if (!rule) return false;

  // Allows self-reference if:
  // 1. Both validFromTypes and validToTypes include the same type
  // 2. allowsCycles is not explicitly false

  return rule.allowsCycles !== false;
}

/**
 * Statistics on relationship rules
 */
export const ValidationStats = {
  totalRelationshipTypes: Object.keys(RelationshipRules).length as number,
  ownershipTypes: ["owns", "created_by"] as const,
  aiTypes: ["clone_of", "trained_on", "powers"] as const,
  contentTypes: ["authored", "generated_by", "published_to", "part_of", "references"] as const,
  communityTypes: ["member_of", "following", "moderates", "participated_in"] as const,
  businessTypes: ["manages", "reports_to", "collaborates_with"] as const,
  tokenTypes: ["holds_tokens", "staked_in", "earned_from"] as const,
  productTypes: ["purchased", "enrolled_in", "completed", "teaching"] as const,
  consolidatedTypes: ["transacted", "notified", "referred", "communicated", "delegated", "approved", "fulfilled"] as const,
} as const;

export const ValidationConfig = {
  CYCLE_DETECTION_ENABLED: true,
  MAX_GRAPH_DEPTH: 100 as number, // Prevent infinite recursion in cycle detection
  STRICT_MODE: true, // Enforce all rules; false = warnings only
} as const;
