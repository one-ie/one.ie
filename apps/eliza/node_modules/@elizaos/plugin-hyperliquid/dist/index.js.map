{"version":3,"sources":["../src/actions/spotTrade.ts","../src/types.ts","../src/templates.ts","../src/actions/priceCheck.ts","../src/actions/cancelOrders.ts","../src/index.ts"],"sourcesContent":["import {\n  type Action,\n  type ActionExample,\n  type IAgentRuntime,\n  type Memory,\n  type State,\n  type HandlerCallback,\n  logger,\n  ModelType,\n  parseKeyValueXml,\n} from \"@elizaos/core\";\nimport { Hyperliquid } from \"hyperliquid\";\nimport {\n  SpotOrderSchema,\n  HyperliquidError,\n  PRICE_VALIDATION,\n} from \"../types.js\";\nimport { priceCheckTemplate, spotTradeTemplate } from \"../templates.js\";\n\nexport const spotTrade: Action = {\n  name: \"SPOT_TRADE\",\n  similes: [\"SPOT_ORDER\", \"SPOT_BUY\", \"SPOT_SELL\"],\n  description: \"Place a spot trade order on Hyperliquid\",\n  validate: async (runtime: IAgentRuntime) => {\n    return !!runtime.getSetting(\"HYPERLIQUID_PRIVATE_KEY\");\n  },\n  handler: async (\n    runtime: IAgentRuntime,\n    message: Memory,\n    state: State | undefined,\n    _options: Record<string, unknown> | undefined,\n    callback?: HandlerCallback\n  ) => {\n    try {\n      // Initialize or update state\n      const currentState = state || (await runtime.composeState(message));\n\n      const contextPrompt = spotTradeTemplate.replace(\n        \"{{recentMessages}}\",\n        currentState.recentMessagesString || \"\"\n      );\n\n      const modelResult = await runtime.useModel(ModelType.TEXT_SMALL, {\n        prompt: contextPrompt,\n      });\n\n      // Parse XML response\n      const parsedContent = parseKeyValueXml(modelResult);\n\n      if (!parsedContent || Object.keys(parsedContent).length === 0) {\n        throw new HyperliquidError(\n          \"Could not parse trading parameters from conversation\"\n        );\n      }\n\n      // Convert string values to appropriate types\n      const orderParams = {\n        coin: parsedContent.coin,\n        is_buy: parsedContent.is_buy === \"true\",\n        sz: parseFloat(parsedContent.sz),\n        limit_px:\n          parsedContent.limit_px === \"null\"\n            ? null\n            : parseFloat(parsedContent.limit_px),\n      };\n\n      logger.info(\n        \"Parsed order parameters:\",\n        JSON.stringify(orderParams, null, 2)\n      );\n\n      // Validate order parameters\n      const validatedOrder = SpotOrderSchema.parse(orderParams);\n      logger.info(\"Validated order:\", validatedOrder);\n\n      // Initialize SDK\n      const sdk = new Hyperliquid({\n        privateKey: runtime.getSetting(\"HYPERLIQUID_PRIVATE_KEY\"),\n        testnet: runtime.getSetting(\"HYPERLIQUID_TESTNET\") === \"true\",\n        enableWs: false,\n      });\n      await sdk.connect();\n\n      // Get market data\n      const [meta, assetCtxs] = await sdk.info.spot.getSpotMetaAndAssetCtxs();\n\n      // Find token and market\n      const tokenIndex = meta.tokens.findIndex(\n        (token) =>\n          token.name.toUpperCase() === validatedOrder.coin.toUpperCase()\n      );\n      if (tokenIndex === -1) {\n        throw new HyperliquidError(\n          `Could not find token ${validatedOrder.coin}`\n        );\n      }\n      const tokenInfo = meta.tokens[tokenIndex];\n      logger.info(\"Found token:\", tokenInfo.name);\n\n      const marketIndex = assetCtxs.findIndex(\n        (ctx) => ctx.coin === `${validatedOrder.coin}-SPOT`\n      );\n      if (marketIndex === -1) {\n        throw new HyperliquidError(\n          `Could not find market for ${validatedOrder.coin}`\n        );\n      }\n      const marketCtx = assetCtxs[marketIndex];\n      if (!marketCtx || !marketCtx.midPx) {\n        throw new HyperliquidError(\n          `Could not get market price for ${validatedOrder.coin}`\n        );\n      }\n\n      // Calculate prices\n      const midPrice = Number(marketCtx.midPx);\n      const isMarketOrder = !validatedOrder.limit_px;\n      let finalPrice: number;\n\n      if (isMarketOrder) {\n        // For market orders, use current price with slippage\n        const slippage = PRICE_VALIDATION.SLIPPAGE;\n        finalPrice = validatedOrder.is_buy\n          ? midPrice * (1 + slippage)\n          : midPrice * (1 - slippage);\n\n        // Validate market order price\n        if (\n          finalPrice < midPrice * PRICE_VALIDATION.MARKET_ORDER.MIN_RATIO ||\n          finalPrice > midPrice * PRICE_VALIDATION.MARKET_ORDER.MAX_RATIO\n        ) {\n          throw new HyperliquidError(\n            `Market order price (${finalPrice.toFixed(2)} USDC) is too far from market price (${midPrice.toFixed(2)} USDC). This might be due to low liquidity.`\n          );\n        }\n      } else {\n        // For limit orders\n        finalPrice = validatedOrder.limit_px!;\n\n        // Validate limit order price is optimal\n        if (validatedOrder.is_buy && finalPrice > midPrice) {\n          throw new HyperliquidError(\n            `Cannot place buy limit order at ${finalPrice.toFixed(2)} USDC because it's above market price (${midPrice.toFixed(2)} USDC). To execute immediately, use a market order. For a limit order, set a price below ${midPrice.toFixed(2)} USDC.`\n          );\n        } else if (!validatedOrder.is_buy && finalPrice < midPrice) {\n          throw new HyperliquidError(\n            `Cannot place sell limit order at ${finalPrice.toFixed(2)} USDC because it's below market price (${midPrice.toFixed(2)} USDC). To execute immediately, use a market order. For a limit order, set a price above ${midPrice.toFixed(2)} USDC.`\n          );\n        }\n\n        // Log warning if price is very different from market\n        if (\n          finalPrice <\n            midPrice * PRICE_VALIDATION.LIMIT_ORDER.WARNING_MIN_RATIO ||\n          finalPrice > midPrice * PRICE_VALIDATION.LIMIT_ORDER.WARNING_MAX_RATIO\n        ) {\n          logger.warn(\n            `Limit price (${finalPrice.toFixed(2)} USDC) is very different from market price (${midPrice.toFixed(2)} USDC). Make sure this is intentional.`,\n            {\n              finalPrice,\n              midPrice,\n              ratio: finalPrice / midPrice,\n            }\n          );\n        }\n      }\n\n      // Prepare and place order\n      const rounded_px = Number(finalPrice.toFixed(tokenInfo.szDecimals));\n      const orderRequest = {\n        coin: `${validatedOrder.coin}-SPOT`,\n        asset: 10000 + marketIndex,\n        is_buy: validatedOrder.is_buy,\n        sz: validatedOrder.sz,\n        limit_px: rounded_px,\n        reduce_only: false,\n        order_type: isMarketOrder\n          ? { market: {} }\n          : { limit: { tif: \"Gtc\" as const } },\n      };\n\n      logger.info(\"Placing order:\", orderRequest);\n      const result = await sdk.exchange.placeOrder(orderRequest);\n\n      // Check if order was rejected\n      if (\n        result.status === \"ok\" &&\n        result.response?.type === \"order\" &&\n        result.response.data?.statuses?.[0]?.error\n      ) {\n        throw new HyperliquidError(result.response.data.statuses[0].error);\n      }\n\n      // Send success callback\n      if (callback) {\n        const action = validatedOrder.is_buy ? \"buy\" : \"sell\";\n        const executionPrice =\n          result.response?.data?.statuses?.[0]?.px || rounded_px;\n        callback({\n          text: `Successfully placed ${isMarketOrder ? \"a market\" : \"a limit\"} order to ${action} ${validatedOrder.sz} ${validatedOrder.coin} at ${executionPrice}`,\n          content: result,\n        });\n      }\n\n      return true;\n    } catch (error) {\n      logger.error(\"Error placing spot order:\", error);\n      const errorMessage =\n        error instanceof Error ? error.message : String(error);\n      if (callback) {\n        callback({\n          text: `Error placing spot order: ${errorMessage}`,\n          content: { error: errorMessage },\n        });\n      }\n      return false;\n    }\n  },\n  examples: [\n    [\n      {\n        name: \"{{user1}}\",\n        content: {\n          text: \"Buy 0.1 HYPE at 20 USDC\",\n        },\n      },\n      {\n        name: \"{{agent}}\",\n        content: {\n          text: \"I'll place a spot buy order for 0.1 HYPE at 20 USDC.\",\n          action: \"SPOT_TRADE\",\n        },\n      },\n      {\n        name: \"{{agent}}\",\n        content: {\n          text: \"Successfully placed a limit order to buy 0.1 HYPE at 20 USDC\",\n        },\n      },\n    ],\n    [\n      {\n        name: \"{{user1}}\",\n        content: {\n          text: \"Sell 2 HYPE at 21 USDC\",\n        },\n      },\n      {\n        name: \"{{agent}}\",\n        content: {\n          text: \"I'll place a spot sell order for 2 HYPE at 21 USDC.\",\n          action: \"SPOT_TRADE\",\n        },\n      },\n      {\n        name: \"{{agent}}\",\n        content: {\n          text: \"Successfully placed a limit order to sell 2 HYPE at 21 USDC\",\n        },\n      },\n    ],\n  ],\n};\n\nexport default spotTrade;\n","import { z } from \"zod\";\n\n// Base configuration types\nexport interface HyperliquidConfig {\n  privateKey: string;\n  testnet?: boolean;\n  walletAddress?: string;\n}\n\n// Enhanced schemas with better validation\nexport const SpotOrderSchema = z.object({\n  coin: z.string().min(1),\n  is_buy: z.boolean(),\n  sz: z.number().positive(),\n  limit_px: z.number().positive().nullable(),\n  reduce_only: z.boolean().default(false),\n  order_type: z\n    .object({\n      limit: z.object({\n        tif: z.enum([\"Ioc\", \"Gtc\"]),\n      }),\n    })\n    .default({ limit: { tif: \"Gtc\" } }),\n});\n\n// Inferred types from schemas\nexport type SpotOrder = z.infer<typeof SpotOrderSchema>;\n\n// Response types\nexport interface OrderResponse {\n  coin: string;\n  orderId: string;\n  status: \"open\" | \"filled\" | \"cancelled\" | \"rejected\";\n  size: number;\n  price: number;\n  is_buy: boolean;\n}\n\n// Error handling types\nexport class HyperliquidError extends Error {\n  constructor(\n    message: string,\n    public code?: number,\n    public details?: unknown\n  ) {\n    super(message);\n    this.name = \"HyperliquidError\";\n  }\n}\n\n// Constants\nexport const ORDER_STATUS = {\n  OPEN: \"open\",\n  FILLED: \"filled\",\n  CANCELLED: \"cancelled\",\n  REJECTED: \"rejected\",\n} as const;\n\nexport const PRICE_VALIDATION = {\n  MARKET_ORDER: {\n    MIN_RATIO: 0.5, // -50% from mid price\n    MAX_RATIO: 1.5, // +50% from mid price\n  },\n  LIMIT_ORDER: {\n    WARNING_MIN_RATIO: 0.2, // -80% from mid price\n    WARNING_MAX_RATIO: 5, // +500% from mid price\n  },\n  SLIPPAGE: 0.01, // 1% slippage for market orders\n} as const;\n\nexport type OrderStatus = keyof typeof ORDER_STATUS;\n\n// Balance types\nexport interface BalanceResponse {\n  coin: string;\n  free: number;\n  locked: number;\n}\n","export const spotTradeTemplate = `<task>\nLook at your LAST RESPONSE in the conversation where you confirmed a trade request.\nBased on ONLY that last message, extract the trading details.\n</task>\n\n<context>\nRecent conversation:\n{{recentMessages}}\n</context>\n\n<rules>\nFor Hyperliquid spot trading:\n\nMarket orders (executes immediately at best available price):\n- \"buy 1 HYPE\" -> coin: HYPE, is_buy: true, sz: 1\n- \"sell 2 HYPE\" -> coin: HYPE, is_buy: false, sz: 2\n- \"market buy 1 HYPE\" -> coin: HYPE, is_buy: true, sz: 1\n- \"market sell 2 HYPE\" -> coin: HYPE, is_buy: false, sz: 2\n\nLimit orders (waits for specified price):\n- \"buy 1 HYPE at 20 USDC\" -> coin: HYPE, is_buy: true, sz: 1, limit_px: 20\n- \"sell 0.5 HYPE at 21 USDC\" -> coin: HYPE, is_buy: false, sz: 0.5, limit_px: 21\n- \"limit buy 1 HYPE at 20 USDC\" -> coin: HYPE, is_buy: true, sz: 1, limit_px: 20\n- \"limit sell 0.5 HYPE at 21 USDC\" -> coin: HYPE, is_buy: false, sz: 0.5, limit_px: 21\n</rules>\n\n<instructions>\n1. Extract the coin symbol (HYPE, ETH, etc.) - just the symbol, no suffixes\n2. Determine if it's a buy (true) or sell (false) order\n3. Extract the size/quantity (sz) to trade as specified in the message\n4. Extract limit_px only if a price was specified with \"at X USDC\", otherwise set to null for market orders\n5. Words like \"market\" or \"limit\" at the start are optional but help clarify intent\n</instructions>\n\nRespond with an XML block containing only the extracted values. Use key-value pairs.\n\nExample response for a market buy:\n<response>\n    <coin>HYPE</coin>\n    <is_buy>true</is_buy>\n    <sz>1</sz>\n    <limit_px>null</limit_px>\n</response>\n\nExample response for a limit sell:\n<response>\n    <coin>HYPE</coin>\n    <is_buy>false</is_buy>\n    <sz>0.5</sz>\n    <limit_px>21</limit_px>\n</response>`;\n\nexport const priceCheckTemplate = `<task>\nLook at your LAST RESPONSE in the conversation where you confirmed which token price to check.\nBased on ONLY that last message, extract the token symbol.\n</task>\n\n<context>\nRecent conversation:\n{{recentMessages}}\n</context>\n\n<examples>\n- \"I'll check PIP price for you\" -> symbol: PIP\n- \"Let me check the price of HYPE\" -> symbol: HYPE\n- \"I'll get the current ETH price\" -> symbol: ETH\n</examples>\n\n<instructions>\n1. Extract the token symbol from your last message\n2. Return just the token symbol (PIP, HYPE, ETH, etc.)\n3. Remove any suffixes like \"-SPOT\" or \"USDC\"\n4. If multiple tokens are mentioned, use the last one\n</instructions>\n\nRespond with an XML block containing only the extracted value.\n\nExample response:\n<response>\n    <symbol>HYPE</symbol>\n</response>`;\n","import {\n  type Action,\n  type ActionExample,\n  type IAgentRuntime,\n  type Memory,\n  type State,\n  type HandlerCallback,\n  logger,\n  ModelType,\n  parseKeyValueXml,\n} from \"@elizaos/core\";\nimport { Hyperliquid } from \"hyperliquid\";\nimport { HyperliquidError } from \"../types.js\";\nimport { priceCheckTemplate } from \"../templates.js\";\n\nexport const priceCheck: Action = {\n  name: \"PRICE_CHECK\",\n  similes: [\"CHECK_PRICE\", \"GET_PRICE\", \"PRICE\", \"CURRENT_PRICE\"],\n  description: \"Get current price for a token on Hyperliquid\",\n  validate: async () => true, // Public endpoint\n  handler: async (\n    runtime: IAgentRuntime,\n    message: Memory,\n    state: State | undefined,\n    _options: Record<string, unknown> | undefined,\n    callback?: HandlerCallback\n  ) => {\n    try {\n      // Initialize or update state\n      const currentState = state || (await runtime.composeState(message));\n\n      const contextPrompt = priceCheckTemplate.replace(\n        \"{{recentMessages}}\",\n        currentState.recentMessagesString || \"\"\n      );\n\n      const result = await runtime.useModel(ModelType.TEXT_SMALL, {\n        prompt: contextPrompt,\n      });\n\n      // Parse XML response\n      const parsedContent = parseKeyValueXml(result);\n\n      if (!parsedContent || !parsedContent.symbol) {\n        throw new HyperliquidError(\n          \"Could not determine which token price to check\"\n        );\n      }\n\n      logger.info(\"Checking price for token:\", parsedContent.symbol);\n\n      // Initialize SDK\n      const sdk = new Hyperliquid({\n        enableWs: false,\n      });\n      await sdk.connect();\n\n      // Get market data\n      const [meta, assetCtxs] = await sdk.info.spot.getSpotMetaAndAssetCtxs();\n\n      // Find token and market\n      const tokenIndex = meta.tokens.findIndex(\n        (token) =>\n          token.name.toUpperCase() === parsedContent.symbol.toUpperCase()\n      );\n      if (tokenIndex === -1) {\n        throw new HyperliquidError(\n          `Could not find token ${parsedContent.symbol}`\n        );\n      }\n\n      const marketIndex = assetCtxs.findIndex(\n        (ctx) => ctx.coin === `${parsedContent.symbol}-SPOT`\n      );\n      if (marketIndex === -1) {\n        throw new HyperliquidError(\n          `Could not find market for ${parsedContent.symbol}`\n        );\n      }\n\n      const marketCtx = assetCtxs[marketIndex];\n      if (!marketCtx || !marketCtx.midPx) {\n        throw new HyperliquidError(\n          `Could not get market price for ${parsedContent.symbol}`\n        );\n      }\n\n      const price = Number(marketCtx.midPx);\n      const dayChange = (\n        ((price - Number(marketCtx.prevDayPx)) / Number(marketCtx.prevDayPx)) *\n        100\n      ).toFixed(2);\n      const volume = Number(marketCtx.dayNtlVlm).toFixed(2);\n\n      if (callback) {\n        callback({\n          text: `${parsedContent.symbol} price: ${price.toFixed(2)} USDC (24h change: ${dayChange}%, volume: ${volume} USDC)`,\n          content: {\n            symbol: parsedContent.symbol,\n            price: price,\n            dayChange: dayChange,\n            volume: volume,\n          },\n        });\n      }\n\n      return true;\n    } catch (error) {\n      logger.error(\"Error checking price:\", error);\n      const errorMessage =\n        error instanceof Error ? error.message : String(error);\n      if (callback) {\n        callback({\n          text: `Error checking price: ${errorMessage}`,\n          content: { error: errorMessage },\n        });\n      }\n      return false;\n    }\n  },\n  examples: [\n    [\n      {\n        name: \"{{user1}}\",\n        content: {\n          text: \"What's the current price of PIP?\",\n        },\n      },\n      {\n        name: \"{{agent}}\",\n        content: {\n          text: \"I'll check the current PIP price for you.\",\n          action: \"PRICE_CHECK\",\n        },\n      },\n      {\n        name: \"{{agent}}\",\n        content: {\n          text: \"PIP price: 19.73 USDC (24h change: -1.82%, volume: 1053445.75 USDC)\",\n        },\n      },\n    ],\n  ],\n};\n\nexport default priceCheck;\n","import {\n  type Action,\n  type ActionExample,\n  type IAgentRuntime,\n  type Memory,\n  type State,\n  type HandlerCallback,\n  logger,\n} from \"@elizaos/core\";\nimport { Hyperliquid } from \"hyperliquid\";\n\nexport const cancelOrders: Action = {\n  name: \"CANCEL_ORDERS\",\n  similes: [\"CANCEL_ALL_ORDERS\", \"CANCEL\", \"CANCEL_ALL\"],\n  description: \"Cancel all open orders on Hyperliquid\",\n  validate: async (runtime: IAgentRuntime) => {\n    return !!runtime.getSetting(\"HYPERLIQUID_PRIVATE_KEY\");\n  },\n  handler: async (\n    runtime: IAgentRuntime,\n    _message: Memory,\n    _state: State | undefined,\n    _options: Record<string, unknown> | undefined,\n    callback?: HandlerCallback\n  ) => {\n    try {\n      // Initialize SDK\n      const sdk = new Hyperliquid({\n        privateKey: runtime.getSetting(\"HYPERLIQUID_PRIVATE_KEY\"),\n        testnet: runtime.getSetting(\"HYPERLIQUID_TESTNET\") === \"true\",\n        enableWs: false,\n      });\n      await sdk.connect();\n\n      logger.info(\"Cancelling all open orders...\");\n      const result = await sdk.custom.cancelAllOrders();\n      logger.info(\"Cancel result:\", result);\n\n      if (callback) {\n        const cancelledCount = result?.response?.data?.statuses?.length || 0;\n        callback({\n          text:\n            cancelledCount > 0\n              ? `Successfully cancelled ${cancelledCount} open order${cancelledCount > 1 ? \"s\" : \"\"}`\n              : \"No open orders to cancel\",\n          content: result,\n        });\n      }\n\n      return true;\n    } catch (error) {\n      logger.error(\"Error cancelling orders:\", error);\n      const errorMessage =\n        error instanceof Error ? error.message : String(error);\n      if (callback) {\n        callback({\n          text: `Error cancelling orders: ${errorMessage}`,\n          content: { error: errorMessage },\n        });\n      }\n      return false;\n    }\n  },\n  examples: [\n    [\n      {\n        name: \"{{user1}}\",\n        content: {\n          text: \"Cancel all my orders\",\n        },\n      },\n      {\n        name: \"{{agent}}\",\n        content: {\n          text: \"I'll cancel all your open orders.\",\n          action: \"CANCEL_ORDERS\",\n        },\n      },\n      {\n        name: \"{{agent}}\",\n        content: {\n          text: \"Successfully cancelled 2 open orders\",\n        },\n      },\n    ],\n  ],\n};\n\nexport default cancelOrders;\n","import type { Plugin } from \"@elizaos/core\";\nimport { spotTrade } from \"./actions/spotTrade\";\nimport { priceCheck } from \"./actions/priceCheck\";\nimport { cancelOrders } from \"./actions/cancelOrders\";\n\nexport const hyperliquidPlugin: Plugin = {\n  name: \"hyperliquid\",\n  description: \"Hyperliquid plugin\",\n  actions: [spotTrade, priceCheck, cancelOrders],\n  providers: [],\n  evaluators: [],\n  services: [],\n};\n\nexport default hyperliquidPlugin;\n"],"mappings":"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","names":["logger","ModelType","parseKeyValueXml","Hyperliquid","ModelType","parseKeyValueXml","logger","Hyperliquid","logger","Hyperliquid"]}