// src/index.ts
import {
  ModelType,
  logger,
  parseBooleanFromText
} from "@elizaos/core";
import { Readable, PassThrough } from "node:stream";
import { Buffer } from "node:buffer";
function getVoiceSettings(runtime) {
  const getSetting = (key, fallback = "") => runtime.getSetting(key) || process.env[key] || fallback;
  return {
    apiKey: getSetting("ELEVENLABS_API_KEY") || getSetting("ELEVENLABS_XI_API_KEY"),
    voiceId: getSetting("ELEVENLABS_VOICE_ID", "EXAVITQu4vr4xnSDxMaL"),
    model: getSetting("ELEVENLABS_MODEL_ID", "eleven_monolingual_v1"),
    stability: getSetting("ELEVENLABS_VOICE_STABILITY", "0.5"),
    latency: getSetting("ELEVENLABS_OPTIMIZE_STREAMING_LATENCY", "0"),
    outputFormat: getSetting("ELEVENLABS_OUTPUT_FORMAT", "pcm_16000"),
    similarity: getSetting("ELEVENLABS_VOICE_SIMILARITY_BOOST", "0.75"),
    style: getSetting("ELEVENLABS_VOICE_STYLE", "0"),
    speakerBoost: parseBooleanFromText(getSetting("ELEVENLABS_VOICE_USE_SPEAKER_BOOST", "true") + "")
  };
}
async function fetchSpeech(runtime, text) {
  const settings = getVoiceSettings(runtime);
  try {
    const response = await fetch(
      `https://api.elevenlabs.io/v1/text-to-speech/${settings.voiceId}/stream?optimize_streaming_latency=${settings.latency}&output_format=${settings.outputFormat}`,
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "xi-api-key": settings.apiKey
        },
        body: JSON.stringify({
          model_id: settings.model,
          text,
          voice_settings: {
            similarity_boost: settings.similarity,
            stability: settings.stability,
            style: settings.style,
            use_speaker_boost: settings.speakerBoost
          }
        })
      }
    );
    if (response.status !== 200) {
      const errorBodyString = await response.text();
      const errorBody = JSON.parse(errorBodyString);
      if (response.status === 401 && errorBody.detail?.status === "quota_exceeded") {
        logger.log("ElevenLabs quota exceeded");
        throw new Error("QUOTA_EXCEEDED");
      }
      logger.error(
        `Received status ${response.status} from Eleven Labs API: ${JSON.stringify(errorBody)}`
      );
      throw new Error(
        `Received status ${response.status} from Eleven Labs API: ${JSON.stringify(errorBody)}`
      );
    }
    if (!response.body) {
      logger.error("Empty response body from Eleven Labs API");
      throw new Error("Empty response body from Eleven Labs API");
    }
    return Readable.fromWeb(response.body);
  } catch (error) {
    const msg = error instanceof Error ? error.message : String(error);
    logger.error(`ElevenLabs fetchSpeech error: ${msg}`);
    throw error instanceof Error ? error : new Error(msg);
  }
}
function getWavHeader(audioLength, sampleRate, channelCount = 1, bitsPerSample = 16) {
  const wavHeader = Buffer.alloc(44);
  wavHeader.write("RIFF", 0);
  wavHeader.writeUInt32LE(36 + audioLength, 4);
  wavHeader.write("WAVE", 8);
  wavHeader.write("fmt ", 12);
  wavHeader.writeUInt32LE(16, 16);
  wavHeader.writeUInt16LE(1, 20);
  wavHeader.writeUInt16LE(channelCount, 22);
  wavHeader.writeUInt32LE(sampleRate, 24);
  wavHeader.writeUInt32LE(sampleRate * bitsPerSample * channelCount / 8, 28);
  wavHeader.writeUInt16LE(bitsPerSample * channelCount / 8, 32);
  wavHeader.writeUInt16LE(bitsPerSample, 34);
  wavHeader.write("data", 36);
  wavHeader.writeUInt32LE(audioLength, 40);
  return wavHeader;
}
function prependWavHeader(readable, audioLength, sampleRate, channelCount = 1, bitsPerSample = 16) {
  const wavHeader = getWavHeader(audioLength, sampleRate, channelCount, bitsPerSample);
  let pushedHeader = false;
  const passThrough = new PassThrough();
  readable.on("data", (data) => {
    if (!pushedHeader) {
      passThrough.push(wavHeader);
      pushedHeader = true;
    }
    passThrough.push(data);
  });
  readable.on("end", () => {
    passThrough.end();
  });
  return passThrough;
}
var elevenLabsPlugin = {
  name: "elevenLabs",
  description: "High-quality text-to-speech synthesis using ElevenLabs API with support for multiple voices and languages",
  models: {
    [ModelType.TEXT_TO_SPEECH]: async (runtime, text) => {
      const settings = getVoiceSettings(runtime);
      logger.log(`[ElevenLabs] Using TEXT_TO_SPEECH model: ${settings.model}`);
      try {
        const stream = await fetchSpeech(runtime, text);
        return settings.outputFormat.startsWith("pcm_") ? prependWavHeader(
          stream,
          1024 * 1024 * 100,
          Number.parseInt(settings.outputFormat.slice(4)),
          1,
          16
        ) : stream;
      } catch (error) {
        const msg = error instanceof Error ? error.message : String(error);
        logger.error(`ElevenLabs model error: ${msg}`);
        throw error instanceof Error ? error : new Error(msg);
      }
    }
  },
  tests: [
    {
      name: "test eleven labs",
      tests: [
        {
          name: "Eleven Labs API key validation",
          fn: async (runtime) => {
            const settings = getVoiceSettings(runtime);
            if (!settings.apiKey) {
              throw new Error("Missing API key: Please provide a valid Eleven Labs API key.");
            }
          }
        },
        {
          name: "Voice settings validation",
          fn: async (runtime) => {
            const settings = getVoiceSettings(runtime);
            if (!settings.voiceId) {
              throw new Error("Missing voice ID configuration");
            }
            const stability = parseFloat(settings.stability);
            if (isNaN(stability) || stability < 0 || stability > 1) {
              throw new Error("Voice stability must be between 0 and 1");
            }
            const similarity = parseFloat(settings.similarity);
            if (isNaN(similarity) || similarity < 0 || similarity > 1) {
              throw new Error("Voice similarity boost must be between 0 and 1");
            }
            logger.success("Voice settings validated successfully");
          }
        },
        {
          name: "WAV header generation",
          fn: async () => {
            const header = getWavHeader(1024, 16e3, 1, 16);
            if (header.length !== 44) {
              throw new Error("WAV header should be exactly 44 bytes");
            }
            if (header.toString("ascii", 0, 4) !== "RIFF") {
              throw new Error("WAV header should start with RIFF");
            }
            if (header.toString("ascii", 8, 12) !== "WAVE") {
              throw new Error("WAV header should contain WAVE identifier");
            }
            logger.success("WAV header generation test passed");
          }
        },
        {
          name: "Eleven Labs API connectivity",
          fn: async (runtime) => {
            const settings = getVoiceSettings(runtime);
            if (!settings.apiKey) {
              logger.warn("Skipping API connectivity test - no API key provided");
              return;
            }
            try {
              await fetchSpeech(runtime, "test");
              logger.success("API connectivity test passed");
            } catch (error) {
              const msg = error instanceof Error ? error.message : String(error);
              if (msg.includes("QUOTA_EXCEEDED")) {
                logger.warn("API quota exceeded - test skipped");
                return;
              }
              logger.error(`API connectivity test failed: ${msg}`);
              throw new Error(`API connectivity test failed: ${msg}`);
            }
          }
        },
        {
          name: "ElevenLabs TTS Generation with stream validation",
          fn: async (runtime) => {
            const settings = getVoiceSettings(runtime);
            if (!settings.apiKey) {
              logger.warn("Skipping TTS generation test - no API key provided");
              return;
            }
            logger.info("[ElevenLabs Test] Starting TTS Generation test");
            const testText = "Hello from ElevenLabs test.";
            try {
              const audioStream = await runtime.useModel(ModelType.TEXT_TO_SPEECH, testText);
              if (!(audioStream instanceof Readable)) {
                throw new Error("TTS output is not a Readable stream");
              }
              logger.info(
                "[ElevenLabs Test] TTS output is a Readable stream. Validating stream..."
              );
              let dataReceived = false;
              let totalBytes = 0;
              let streamEnded = false;
              let streamError = null;
              let headerValidated = false;
              audioStream.on("data", (chunk) => {
                dataReceived = true;
                totalBytes += chunk.length;
                if (!headerValidated && settings.outputFormat.startsWith("pcm_") && chunk.length >= 44) {
                  const header = chunk.slice(0, 4).toString("ascii");
                  if (header === "RIFF") {
                    headerValidated = true;
                    logger.info("[ElevenLabs Test] WAV header validated");
                  }
                }
                logger.info(
                  `[ElevenLabs Test] Received chunk: ${chunk.length} bytes, total: ${totalBytes} bytes`
                );
              });
              audioStream.on("end", () => {
                logger.info("[ElevenLabs Test] Audio stream ended successfully");
                streamEnded = true;
              });
              audioStream.on("error", (err) => {
                logger.error("[ElevenLabs Test] Audio stream error:", err);
                streamError = err;
                streamEnded = true;
              });
              await new Promise((resolve, reject) => {
                const timeoutId = setTimeout(() => {
                  if (!streamEnded) {
                    reject(
                      new Error("[ElevenLabs Test] Stream processing timed out after 15 seconds")
                    );
                  } else {
                    resolve();
                  }
                }, 15e3);
                audioStream.on("end", () => {
                  clearTimeout(timeoutId);
                  resolve();
                });
                audioStream.on("error", (err) => {
                  clearTimeout(timeoutId);
                  reject(err);
                });
              });
              if (streamError) {
                throw streamError;
              }
              if (!dataReceived) {
                throw new Error("[ElevenLabs Test] No audio data was received from the stream");
              }
              if (totalBytes === 0) {
                throw new Error("[ElevenLabs Test] Received empty audio stream");
              }
              logger.success(
                `[ElevenLabs Test] TTS test completed successfully. Received ${totalBytes} bytes of audio data`
              );
            } catch (error) {
              const msg = error instanceof Error ? error.message : String(error);
              if (msg.includes("QUOTA_EXCEEDED")) {
                logger.warn("[ElevenLabs Test] API quota exceeded - test skipped");
                return;
              }
              if (msg.includes("Missing API key") || msg.includes("401")) {
                logger.warn("[ElevenLabs Test] Test skipped due to missing or invalid API key");
                return;
              }
              logger.error("[ElevenLabs Test] TTS Generation test failed:", msg);
              throw new Error(`TTS Generation test failed: ${msg}`);
            }
          }
        },
        {
          name: "Output format handling",
          fn: async (runtime) => {
            const settings = getVoiceSettings(runtime);
            const pcmFormats = ["pcm_16000", "pcm_22050", "pcm_24000", "pcm_44100"];
            for (const format of pcmFormats) {
              if (format.startsWith("pcm_")) {
                const sampleRate = Number.parseInt(format.slice(4));
                if (isNaN(sampleRate) || sampleRate <= 0) {
                  throw new Error(`Invalid PCM format: ${format}`);
                }
              }
            }
            if (settings.outputFormat.startsWith("pcm_")) {
              const sampleRate = Number.parseInt(settings.outputFormat.slice(4));
              if (isNaN(sampleRate) || sampleRate <= 0) {
                throw new Error(`Invalid output format configuration: ${settings.outputFormat}`);
              }
              logger.success(
                `Output format validated: ${settings.outputFormat} with sample rate ${sampleRate}Hz`
              );
            } else {
              logger.success(`Output format validated: ${settings.outputFormat} (non-PCM format)`);
            }
          }
        }
      ]
    }
  ]
};
var index_default = elevenLabsPlugin;
export {
  index_default as default,
  elevenLabsPlugin
};
//# sourceMappingURL=index.js.map