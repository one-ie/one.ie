import { type Content, type IAgentRuntime } from '@elizaos/core';
import type { Message, Update } from '@telegraf/types';
import type { Context, NarrowedContext, Telegraf } from 'telegraf';
import { TelegramContent } from './types';
/**
 * Enum representing different types of media.
 * @enum { string }
 * @readonly
 */
export declare enum MediaType {
    PHOTO = "photo",
    VIDEO = "video",
    DOCUMENT = "document",
    AUDIO = "audio",
    ANIMATION = "animation"
}
/**
 * Class representing a message manager.
 * @class
 */
export declare class MessageManager {
    bot: Telegraf<Context>;
    protected runtime: IAgentRuntime;
    /**
     * Constructor for creating a new instance of a BotAgent.
     *
     * @param {Telegraf<Context>} bot - The Telegraf instance used for interacting with the bot platform.
     * @param {IAgentRuntime} runtime - The runtime environment for the agent.
     */
    constructor(bot: Telegraf<Context>, runtime: IAgentRuntime);
    /**
     * Process an image from a Telegram message to extract the image URL and description.
     *
     * @param {Message} message - The Telegram message object containing the image.
     * @returns {Promise<{ description: string } | null>} The description of the processed image or null if no image found.
     */
    processImage(message: Message): Promise<{
        description: string;
    } | null>;
    /**
     * Sends a message in chunks, handling attachments and splitting the message if necessary
     *
     * @param {Context} ctx - The context object representing the current state of the bot
     * @param {TelegramContent} content - The content of the message to be sent
     * @param {number} [replyToMessageId] - The ID of the message to reply to, if any
     * @returns {Promise<Message.TextMessage[]>} - An array of TextMessage objects representing the messages sent
     */
    sendMessageInChunks(ctx: Context, content: TelegramContent, replyToMessageId?: number): Promise<Message.TextMessage[]>;
    /**
     * Sends media to a chat using the Telegram API.
     *
     * @param {Context} ctx - The context object containing information about the current chat.
     * @param {string} mediaPath - The path to the media to be sent, either a URL or a local file path.
     * @param {MediaType} type - The type of media being sent (PHOTO, VIDEO, DOCUMENT, AUDIO, or ANIMATION).
     * @param {string} [caption] - Optional caption for the media being sent.
     *
     * @returns {Promise<void>} A Promise that resolves when the media is successfully sent.
     */
    sendMedia(ctx: Context, mediaPath: string, type: MediaType, caption?: string): Promise<void>;
    /**
     * Splits a given text into an array of strings based on the maximum message length.
     *
     * @param {string} text - The text to split into chunks.
     * @returns {string[]} An array of strings with each element representing a chunk of the original text.
     */
    private splitMessage;
    /**
     * Handle incoming messages from Telegram and process them accordingly.
     * @param {Context} ctx - The context object containing information about the message.
     * @returns {Promise<void>}
     */
    handleMessage(ctx: Context): Promise<void>;
    /**
     * Handles the reaction event triggered by a user reacting to a message.
     * @param {NarrowedContext<Context<Update>, Update.MessageReactionUpdate>} ctx The context of the message reaction update
     * @returns {Promise<void>} A Promise that resolves when the reaction handling is complete
     */
    handleReaction(ctx: NarrowedContext<Context<Update>, Update.MessageReactionUpdate>): Promise<void>;
    /**
     * Sends a message to a Telegram chat and emits appropriate events
     * @param {number | string} chatId - The Telegram chat ID to send the message to
     * @param {Content} content - The content to send
     * @param {number} [replyToMessageId] - Optional message ID to reply to
     * @returns {Promise<Message.TextMessage[]>} The sent messages
     */
    sendMessage(chatId: number | string, content: Content, replyToMessageId?: number): Promise<Message.TextMessage[]>;
}
