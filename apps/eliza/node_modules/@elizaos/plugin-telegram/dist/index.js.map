{"version":3,"sources":["../src/constants.ts","../src/service.ts","../src/messageManager.ts","../src/utils.ts","../src/tests.ts","../src/index.ts"],"sourcesContent":["export const MESSAGE_CONSTANTS = {\n  MAX_MESSAGES: 50,\n  RECENT_MESSAGE_COUNT: 5,\n  CHAT_HISTORY_COUNT: 10,\n  DEFAULT_SIMILARITY_THRESHOLD: 0.6,\n  DEFAULT_SIMILARITY_THRESHOLD_FOLLOW_UPS: 0.4,\n  INTEREST_DECAY_TIME: 5 * 60 * 1000, // 5 minutes\n  PARTIAL_INTEREST_DECAY: 3 * 60 * 1000, // 3 minutes\n} as const;\n\nexport const TELEGRAM_SERVICE_NAME = 'telegram';\n","import {\n  ChannelType,\n  type Content,\n  type Entity,\n  EventType,\n  type IAgentRuntime,\n  Role,\n  type Room,\n  Service,\n  type TargetInfo,\n  type UUID,\n  type World,\n  createUniqueUuid,\n  logger,\n} from '@elizaos/core';\nimport { type Context, Telegraf } from 'telegraf';\nimport { type ChatMemberOwner, type ChatMemberAdministrator, type User } from 'telegraf/types';\nimport { TELEGRAM_SERVICE_NAME } from './constants';\nimport { MessageManager } from './messageManager';\nimport { TelegramEventTypes, type TelegramWorldPayload } from './types';\n\n/**\n * Class representing a Telegram service that allows the agent to send and receive messages on Telegram.\n * This service handles all Telegram-specific functionality including:\n * - Initializing and managing the Telegram bot\n * - Setting up middleware for preprocessing messages\n * - Handling message and reaction events\n * - Synchronizing Telegram chats, users, and entities with the agent runtime\n * - Managing forum topics as separate rooms\n *\n * @extends Service\n */\nexport class TelegramService extends Service {\n  static serviceType = TELEGRAM_SERVICE_NAME;\n  capabilityDescription = 'The agent is able to send and receive messages on telegram';\n  private bot: Telegraf<Context> | null;\n  public messageManager: MessageManager | null;\n  private options;\n  private knownChats: Map<string, any> = new Map();\n  private syncedEntityIds: Set<string> = new Set<string>();\n\n  /**\n   * Constructor for TelegramService class.\n   * @param {IAgentRuntime} runtime - The runtime object for the agent.\n   */\n  constructor(runtime: IAgentRuntime) {\n    super(runtime);\n    logger.log('üì± Constructing new TelegramService...');\n\n    // Check if Telegram bot token is available and valid\n    const botToken = runtime.getSetting('TELEGRAM_BOT_TOKEN') as string;\n    if (!botToken || botToken.trim() === '') {\n      logger.warn('Telegram Bot Token not provided - Telegram functionality will be unavailable');\n      this.bot = null;\n      this.messageManager = null;\n      return;\n    }\n\n    this.options = {\n      telegram: {\n        apiRoot:\n          runtime.getSetting('TELEGRAM_API_ROOT') ||\n          process.env.TELEGRAM_API_ROOT ||\n          'https://api.telegram.org',\n      },\n    };\n\n    try {\n      this.bot = new Telegraf(botToken, this.options);\n      this.messageManager = new MessageManager(this.bot, this.runtime);\n      logger.log('‚úÖ TelegramService constructor completed');\n    } catch (error) {\n      logger.error(\n        `Error initializing Telegram bot: ${error instanceof Error ? error.message : String(error)}`\n      );\n      this.bot = null;\n      this.messageManager = null;\n    }\n  }\n\n  /**\n   * Starts the Telegram service for the given runtime.\n   *\n   * @param {IAgentRuntime} runtime - The agent runtime to start the Telegram service for.\n   * @returns {Promise<TelegramService>} A promise that resolves with the initialized TelegramService.\n   */\n  static async start(runtime: IAgentRuntime): Promise<TelegramService> {\n    // Remove validateTelegramConfig call to allow service to start without token\n\n    const service = new TelegramService(runtime);\n\n    // If bot is not initialized (no token), return the service without further initialization\n    if (!service.bot) {\n      logger.warn('Telegram service started without bot functionality - no bot token provided');\n      return service;\n    }\n\n    const maxRetries = 5;\n    let retryCount = 0;\n    let lastError: Error | null = null;\n\n    while (retryCount < maxRetries) {\n      try {\n        logger.success(\n          `‚úÖ Telegram client successfully started for character ${runtime.character.name}`\n        );\n\n        logger.log('üöÄ Starting Telegram bot...');\n        await service.initializeBot();\n\n        // Set up middlewares before message handlers to ensure proper preprocessing\n        service.setupMiddlewares();\n\n        // Set up message handlers after middlewares\n        service.setupMessageHandlers();\n\n        // Wait for bot to be ready by testing getMe()\n        await service.bot!.telegram.getMe();\n\n        return service;\n      } catch (error) {\n        lastError = error instanceof Error ? error : new Error(String(error));\n        logger.error(\n          `Telegram initialization attempt ${retryCount + 1} failed: ${lastError.message}`\n        );\n        retryCount++;\n\n        if (retryCount < maxRetries) {\n          const delay = 2 ** retryCount * 1000; // Exponential backoff\n          logger.info(`Retrying Telegram initialization in ${delay / 1000} seconds...`);\n          await new Promise((resolve) => setTimeout(resolve, delay));\n        }\n      }\n    }\n\n    logger.error(\n      `Telegram initialization failed after ${maxRetries} attempts. Last error: ${lastError?.message}. Service will continue without Telegram functionality.`\n    );\n\n    // Return the service even if initialization failed, to prevent server crash\n    return service;\n  }\n\n  /**\n   * Stops the agent runtime.\n   * @param {IAgentRuntime} runtime - The agent runtime to stop\n   */\n  static async stop(runtime: IAgentRuntime) {\n    // Implement shutdown if necessary\n    const tgClient = runtime.getService(TELEGRAM_SERVICE_NAME);\n    if (tgClient) {\n      await tgClient.stop();\n    }\n  }\n\n  /**\n   * Asynchronously stops the bot.\n   *\n   * @returns A Promise that resolves once the bot has stopped.\n   */\n  async stop(): Promise<void> {\n    this.bot?.stop();\n  }\n\n  /**\n   * Initializes the Telegram bot by launching it, getting bot info, and setting up message manager.\n   * @returns {Promise<void>} A Promise that resolves when the initialization is complete.\n   */\n  private async initializeBot(): Promise<void> {\n    this.bot?.start((ctx) => {\n      this.runtime.emitEvent([TelegramEventTypes.SLASH_START], {\n        // we don't need this\n        ctx,\n      });\n    });\n    this.bot?.launch({\n      dropPendingUpdates: true,\n      allowedUpdates: ['message', 'message_reaction'],\n    });\n\n    // Get bot info for identification purposes\n    const botInfo = await this.bot!.telegram.getMe();\n    logger.log(`Bot info: ${JSON.stringify(botInfo)}`);\n\n    // Handle sigint and sigterm signals to gracefully stop the bot\n    process.once('SIGINT', () => this.bot?.stop('SIGINT'));\n    process.once('SIGTERM', () => this.bot?.stop('SIGTERM'));\n  }\n\n  /**\n   * Sets up the middleware chain for preprocessing messages before they reach handlers.\n   * This critical method establishes a sequential processing pipeline that:\n   *\n   * 1. Authorization - Verifies if a chat is allowed to interact with the bot based on configured settings\n   * 2. Chat Discovery - Ensures chat entities and worlds exist in the runtime, creating them if needed\n   * 3. Forum Topics - Handles Telegram forum topics as separate rooms for better conversation management\n   * 4. Entity Synchronization - Ensures message senders are properly synchronized as entities\n   *\n   * The middleware chain runs in sequence for each message, with each step potentially\n   * enriching the context or stopping processing if conditions aren't met.\n   * This preprocessing is essential for maintaining consistent state before message handlers execute.\n   *\n   * @private\n   */\n  private setupMiddlewares(): void {\n    // Register the authorization middleware\n    this.bot?.use(this.authorizationMiddleware.bind(this));\n\n    // Register the chat and entity management middleware\n    this.bot?.use(this.chatAndEntityMiddleware.bind(this));\n  }\n\n  /**\n   * Authorization middleware - checks if chat is allowed to interact with the bot\n   * based on the TELEGRAM_ALLOWED_CHATS configuration.\n   *\n   * @param {Context} ctx - The context of the incoming update\n   * @param {Function} next - The function to call to proceed to the next middleware\n   * @returns {Promise<void>}\n   * @private\n   */\n  private async authorizationMiddleware(ctx: Context, next: Function): Promise<void> {\n    if (!(await this.isGroupAuthorized(ctx))) {\n      // Skip further processing if chat is not authorized\n      logger.debug('Chat not authorized, skipping message processing');\n      return;\n    }\n    await next();\n  }\n\n  /**\n   * Chat and entity management middleware - handles new chats, forum topics, and entity synchronization.\n   * This middleware implements decision logic to determine which operations are needed based on\n   * the chat type and whether we've seen this chat before.\n   *\n   * @param {Context} ctx - The context of the incoming update\n   * @param {Function} next - The function to call to proceed to the next middleware\n   * @returns {Promise<void>}\n   * @private\n   */\n  private async chatAndEntityMiddleware(ctx: Context, next: Function): Promise<void> {\n    if (!ctx.chat) return next();\n\n    const chatId = ctx.chat.id.toString();\n\n    // If we haven't seen this chat before, process it as a new chat\n    if (!this.knownChats.has(chatId)) {\n      // Process the new chat - creates world, room, topic room (if applicable) and entities\n      await this.handleNewChat(ctx);\n      // Skip entity synchronization for new chats and proceed to the next middleware\n      return next();\n    }\n\n    // For existing chats, determine the required operations based on chat type\n    await this.processExistingChat(ctx);\n\n    await next();\n  }\n\n  /**\n   * Process an existing chat based on chat type and message properties.\n   * Different chat types require different processing steps.\n   *\n   * @param {Context} ctx - The context of the incoming update\n   * @returns {Promise<void>}\n   * @private\n   */\n  private async processExistingChat(ctx: Context): Promise<void> {\n    if (!ctx.chat) return;\n\n    const chat = ctx.chat;\n\n    // Handle forum topics for supergroups with forums\n    if (chat.type === 'supergroup' && chat.is_forum && ctx.message?.message_thread_id) {\n      try {\n        await this.handleForumTopic(ctx);\n      } catch (error) {\n        logger.error({ error }, `Error handling forum topic: ${error}`);\n      }\n    }\n\n    // For non-private chats, synchronize entity information\n    if (ctx.from && ctx.chat.type !== 'private') {\n      await this.syncEntity(ctx);\n    }\n  }\n\n  /**\n   * Sets up message and reaction handlers for the bot.\n   * Configures event handlers to process incoming messages and reactions.\n   *\n   * @private\n   */\n  private setupMessageHandlers(): void {\n    // Regular message handler\n    this.bot?.on('message', async (ctx) => {\n      try {\n        // Message handling is now simplified since all preprocessing is done by middleware\n        await this.messageManager!.handleMessage(ctx);\n      } catch (error) {\n        logger.error({ error }, 'Error handling message');\n      }\n    });\n\n    // Reaction handler\n    this.bot?.on('message_reaction', async (ctx) => {\n      try {\n        await this.messageManager!.handleReaction(ctx);\n      } catch (error) {\n        logger.error({ error }, 'Error handling reaction');\n      }\n    });\n  }\n\n  /**\n   * Checks if a group is authorized, based on the TELEGRAM_ALLOWED_CHATS setting.\n   * @param {Context} ctx - The context of the incoming update.\n   * @returns {Promise<boolean>} A Promise that resolves with a boolean indicating if the group is authorized.\n   */\n  private async isGroupAuthorized(ctx: Context): Promise<boolean> {\n    const chatId = ctx.chat?.id.toString();\n    if (!chatId) return false;\n\n    const allowedChats = this.runtime.getSetting('TELEGRAM_ALLOWED_CHATS');\n    if (!allowedChats) {\n      return true;\n    }\n\n    try {\n      const allowedChatsList = JSON.parse(allowedChats as string);\n      return allowedChatsList.includes(chatId);\n    } catch (error) {\n      logger.error({ error }, 'Error parsing TELEGRAM_ALLOWED_CHATS');\n      return false;\n    }\n  }\n\n  /**\n   * Synchronizes an entity from a message context with the runtime system.\n   * This method handles three cases:\n   * 1. Message sender - most common case\n   * 2. New chat member - when a user joins the chat\n   * 3. Left chat member - when a user leaves the chat\n   *\n   * @param {Context} ctx - The context of the incoming update\n   * @returns {Promise<void>}\n   * @private\n   */\n  private async syncEntity(ctx: Context): Promise<void> {\n    if (!ctx.chat) return;\n\n    const chat = ctx.chat;\n    const chatId = chat.id.toString();\n    const worldId = createUniqueUuid(this.runtime, chatId) as UUID;\n    const roomId = createUniqueUuid(\n      this.runtime,\n      ctx.message?.message_thread_id\n        ? `${ctx.chat.id}-${ctx.message.message_thread_id}`\n        : ctx.chat.id.toString()\n    ) as UUID;\n\n    // Handle all three entity sync cases separately for clarity\n    await this.syncMessageSender(ctx, worldId, roomId, chatId);\n    await this.syncNewChatMember(ctx, worldId, roomId, chatId);\n    await this.syncLeftChatMember(ctx);\n  }\n\n  /**\n   * Synchronizes the message sender entity with the runtime system.\n   * This is the most common entity sync case.\n   *\n   * @param {Context} ctx - The context of the incoming update\n   * @param {UUID} worldId - The ID of the world\n   * @param {UUID} roomId - The ID of the room\n   * @param {string} chatId - The ID of the chat\n   * @returns {Promise<void>}\n   * @private\n   */\n  private async syncMessageSender(\n    ctx: Context,\n    worldId: UUID,\n    roomId: UUID,\n    chatId: string\n  ): Promise<void> {\n    // Handle message sender\n    if (ctx.from && !this.syncedEntityIds.has(ctx.from.id.toString())) {\n      const telegramId = ctx.from.id.toString();\n      const entityId = createUniqueUuid(this.runtime, telegramId) as UUID;\n\n      await this.runtime.ensureConnection({\n        entityId,\n        roomId: roomId,\n        userName: ctx.from.username,\n        userId: telegramId as UUID,\n        name: ctx.from.first_name || ctx.from.username || 'Unknown User',\n        source: 'telegram',\n        channelId: chatId,\n        serverId: chatId,\n        type: ChannelType.GROUP,\n        worldId: worldId,\n      });\n\n      this.syncedEntityIds.add(entityId);\n    }\n  }\n\n  /**\n   * Synchronizes a new chat member entity with the runtime system.\n   * Triggered when a user joins the chat.\n   *\n   * @param {Context} ctx - The context of the incoming update\n   * @param {UUID} worldId - The ID of the world\n   * @param {UUID} roomId - The ID of the room\n   * @param {string} chatId - The ID of the chat\n   * @returns {Promise<void>}\n   * @private\n   */\n  private async syncNewChatMember(\n    ctx: Context,\n    worldId: UUID,\n    roomId: UUID,\n    chatId: string\n  ): Promise<void> {\n    // Handle new chat member\n    if (ctx.message && 'new_chat_member' in ctx.message) {\n      const newMember = ctx.message.new_chat_member as any;\n      const telegramId = newMember.id.toString();\n      const entityId = createUniqueUuid(this.runtime, telegramId) as UUID;\n\n      // Skip if we've already synced this entity\n      if (this.syncedEntityIds.has(telegramId)) return;\n\n      // We call ensure connection here for this user.\n      await this.runtime.ensureConnection({\n        entityId,\n        roomId: roomId,\n        userName: newMember.username,\n        userId: telegramId,\n        name: newMember.first_name || newMember.username || 'Unknown User',\n        source: 'telegram',\n        channelId: chatId,\n        serverId: chatId,\n        type: ChannelType.GROUP,\n        worldId: worldId,\n      });\n\n      this.syncedEntityIds.add(entityId);\n\n      this.runtime.emitEvent([TelegramEventTypes.ENTITY_JOINED], {\n        runtime: this.runtime,\n        entityId,\n        worldId,\n        newMember,\n        ctx,\n      });\n    }\n  }\n\n  /**\n   * Updates entity status when a user leaves the chat.\n   *\n   * @param {Context} ctx - The context of the incoming update\n   * @returns {Promise<void>}\n   * @private\n   */\n  private async syncLeftChatMember(ctx: Context): Promise<void> {\n    // Handle left chat member\n    if (ctx.message && 'left_chat_member' in ctx.message) {\n      const leftMember = ctx.message.left_chat_member as any;\n      const telegramId = leftMember.id.toString();\n      const entityId = createUniqueUuid(this.runtime, telegramId) as UUID;\n\n      const existingEntity = await this.runtime.getEntityById(entityId);\n      if (existingEntity) {\n        existingEntity.metadata = {\n          ...existingEntity.metadata,\n          status: 'INACTIVE',\n          leftAt: Date.now(),\n        };\n        await this.runtime.updateEntity(existingEntity);\n      }\n    }\n  }\n\n  /**\n   * Handles forum topics by creating appropriate rooms in the runtime system.\n   * This enables proper conversation management for Telegram's forum feature.\n   *\n   * @param {Context} ctx - The context of the incoming update\n   * @returns {Promise<void>}\n   * @private\n   */\n  private async handleForumTopic(ctx: Context): Promise<void> {\n    if (!ctx.chat || !ctx.message?.message_thread_id) return;\n\n    const chat = ctx.chat;\n    const chatId = chat.id.toString();\n    const worldId = createUniqueUuid(this.runtime, chatId) as UUID;\n\n    const room = await this.buildForumTopicRoom(ctx, worldId);\n    if (!room) return;\n\n    await this.runtime.ensureRoomExists(room);\n  }\n\n  /**\n   * Builds entity for message sender\n   */\n  private buildMsgSenderEntity(from: User): Entity | null {\n    if (!from) return null;\n\n    const userId = createUniqueUuid(this.runtime, from.id.toString()) as UUID;\n    const telegramId = from.id.toString();\n\n    return {\n      id: userId,\n      agentId: this.runtime.agentId,\n      names: [from.first_name || from.username || 'Unknown User'],\n      metadata: {\n        telegram: {\n          id: telegramId,\n          username: from.username,\n          name: from.first_name || from.username || 'Unknown User',\n        },\n      },\n    };\n  }\n\n  /**\n   * Handles new chat discovery and emits WORLD_JOINED event.\n   * This is a critical function that ensures new chats are properly\n   * registered in the runtime system and appropriate events are emitted.\n   *\n   * @param {Context} ctx - The context of the incoming update\n   * @returns {Promise<void>}\n   * @private\n   */\n  private async handleNewChat(ctx: Context): Promise<void> {\n    if (!ctx.chat) return;\n\n    const chat = ctx.chat;\n    const chatId = chat.id.toString();\n\n    // Mark this chat as known\n    this.knownChats.set(chatId, chat);\n\n    // Get chat title and channel type\n    const { chatTitle, channelType } = this.getChatTypeInfo(chat);\n\n    const worldId = createUniqueUuid(this.runtime, chatId) as UUID;\n\n    const existingWorld = await this.runtime.getWorld(worldId);\n    if (existingWorld) {\n      return;\n    }\n\n    const userId = ctx.from\n      ? (createUniqueUuid(this.runtime, ctx.from.id.toString()) as UUID)\n      : null;\n\n    // Fetch admin information for proper role assignment\n    let admins: (ChatMemberOwner | ChatMemberAdministrator)[] = [];\n    let owner: ChatMemberOwner | null = null;\n    if (chat.type === 'group' || chat.type === 'supergroup' || chat.type === 'channel') {\n      try {\n        const chatAdmins = await ctx.getChatAdministrators();\n        admins = chatAdmins;\n        const foundOwner = admins.find(\n          (admin): admin is ChatMemberOwner => admin.status === 'creator'\n        );\n        owner = foundOwner || null;\n      } catch (error) {\n        logger.warn(\n          `Could not get chat administrators: ${error instanceof Error ? error.message : String(error)}`\n        );\n      }\n    }\n\n    let ownerId = userId;\n\n    if (owner) {\n      ownerId = createUniqueUuid(this.runtime, String(owner.user.id)) as UUID;\n    }\n\n    // Build world representation\n    const world: World = {\n      id: worldId,\n      name: chatTitle,\n      agentId: this.runtime.agentId,\n      serverId: chatId,\n      metadata: {\n        source: 'telegram',\n        ...(ownerId && { ownership: { ownerId } }),\n        roles: ownerId\n          ? {\n              [ownerId]: Role.OWNER,\n            }\n          : {},\n        chatType: chat.type,\n        isForumEnabled: chat.type === 'supergroup' && chat.is_forum,\n      },\n    };\n\n    // Directly ensure world exists instead of using syncTelegram\n    await this.runtime.ensureWorldExists(world);\n\n    // Create the main room for the chat\n    const generalRoom: Room = {\n      id: createUniqueUuid(this.runtime, chatId) as UUID,\n      name: chatTitle,\n      source: 'telegram',\n      type: channelType,\n      channelId: chatId,\n      serverId: chatId,\n      worldId,\n    };\n\n    // Directly ensure room exists instead of using syncTelegram\n    await this.runtime.ensureRoomExists(generalRoom);\n\n    // Prepare the rooms array starting with the main room\n    const rooms = [generalRoom];\n\n    // If this is a message in a forum topic, add the topic room as well\n    if (chat.type === 'supergroup' && chat.is_forum && ctx.message?.message_thread_id) {\n      const topicRoom = await this.buildForumTopicRoom(ctx, worldId);\n      if (topicRoom) {\n        rooms.push(topicRoom);\n        await this.runtime.ensureRoomExists(topicRoom);\n      }\n    }\n\n    // Build entities from chat\n    const entities = await this.buildStandardizedEntities(chat);\n\n    // Add sender if not already in entities\n    if (ctx.from) {\n      const senderEntity = this.buildMsgSenderEntity(ctx.from);\n      if (senderEntity && senderEntity.id && !entities.some((e) => e.id === senderEntity.id)) {\n        entities.push(senderEntity);\n        this.syncedEntityIds.add(senderEntity.id);\n      }\n    }\n\n    // Use the new batch processing method for entities\n    await this.batchProcessEntities(\n      entities,\n      generalRoom.id!,\n      generalRoom.channelId!,\n      generalRoom.serverId!,\n      generalRoom.type,\n      worldId\n    );\n\n    // Create payload for world events\n    const telegramWorldPayload: TelegramWorldPayload = {\n      runtime: this.runtime,\n      world,\n      rooms,\n      entities,\n      source: 'telegram',\n      chat,\n      botUsername: this.bot?.botInfo?.username,\n    };\n\n    // Emit telegram-specific world joined event\n    if (chat.type !== 'private') {\n      await this.runtime.emitEvent(TelegramEventTypes.WORLD_JOINED, telegramWorldPayload);\n    }\n\n    // Finally emit the standard WORLD_JOINED event\n    await this.runtime.emitEvent(EventType.WORLD_JOINED, {\n      runtime: this.runtime,\n      world,\n      rooms,\n      entities,\n      source: 'telegram',\n    });\n  }\n\n  /**\n   * Processes entities in batches to prevent overwhelming the system.\n   *\n   * @param {Entity[]} entities - The entities to process\n   * @param {UUID} roomId - The ID of the room to connect entities to\n   * @param {string} channelId - The channel ID\n   * @param {string} serverId - The server ID\n   * @param {ChannelType} roomType - The type of the room\n   * @param {UUID} worldId - The ID of the world\n   * @returns {Promise<void>}\n   * @private\n   */\n  private async batchProcessEntities(\n    entities: Entity[],\n    roomId: UUID,\n    channelId: string,\n    serverId: string,\n    roomType: ChannelType,\n    worldId: UUID\n  ): Promise<void> {\n    const batchSize = 50;\n\n    for (let i = 0; i < entities.length; i += batchSize) {\n      const entityBatch = entities.slice(i, i + batchSize);\n\n      // Process each entity in the batch concurrently\n      await Promise.all(\n        entityBatch.map(async (entity: Entity) => {\n          try {\n            if (entity.id) {\n              const telegramMetadata = entity.metadata?.telegram as\n                | {\n                    username?: string;\n                    name?: string;\n                    id?: string;\n                  }\n                | undefined;\n\n              await this.runtime.ensureConnection({\n                entityId: entity.id,\n                roomId: roomId,\n                userName: telegramMetadata?.username,\n                name: telegramMetadata?.name,\n                userId: telegramMetadata?.id as UUID,\n                source: 'telegram',\n                channelId: channelId,\n                serverId: serverId,\n                type: roomType,\n                worldId: worldId,\n              });\n            } else {\n              logger.warn(\n                `Skipping entity sync due to missing ID: ${JSON.stringify(entity.names)}`\n              );\n            }\n          } catch (err) {\n            const telegramMetadata = entity.metadata?.telegram as\n              | {\n                  username?: string;\n                }\n              | undefined;\n            logger.warn(`Failed to sync user ${telegramMetadata?.username}: ${err}`);\n          }\n        })\n      );\n\n      // Add a small delay between batches if not the last batch\n      if (i + batchSize < entities.length) {\n        await new Promise((resolve) => setTimeout(resolve, 500));\n      }\n    }\n  }\n\n  /**\n   * Gets chat title and channel type based on Telegram chat type.\n   * Maps Telegram-specific chat types to standardized system types.\n   *\n   * @param {any} chat - The Telegram chat object\n   * @returns {Object} Object containing chatTitle and channelType\n   * @private\n   */\n  private getChatTypeInfo(chat: any): { chatTitle: string; channelType: ChannelType } {\n    let chatTitle: string;\n    let channelType: ChannelType;\n\n    switch (chat.type) {\n      case 'private':\n        chatTitle = `Chat with ${chat.first_name || 'Unknown User'}`;\n        channelType = ChannelType.DM;\n        break;\n      case 'group':\n        chatTitle = chat.title || 'Unknown Group';\n        channelType = ChannelType.GROUP;\n        break;\n      case 'supergroup':\n        chatTitle = chat.title || 'Unknown Supergroup';\n        channelType = ChannelType.GROUP;\n        break;\n      case 'channel':\n        chatTitle = chat.title || 'Unknown Channel';\n        channelType = ChannelType.FEED;\n        break;\n      default:\n        chatTitle = 'Unknown Chat';\n        channelType = ChannelType.GROUP;\n    }\n\n    return { chatTitle, channelType };\n  }\n\n  /**\n   * Builds standardized entity representations from Telegram chat data.\n   * Transforms Telegram-specific user data into system-standard Entity objects.\n   *\n   * @param {any} chat - The Telegram chat object\n   * @returns {Promise<Entity[]>} Array of standardized Entity objects\n   * @private\n   */\n  private async buildStandardizedEntities(chat: any): Promise<Entity[]> {\n    const entities: Entity[] = [];\n\n    try {\n      // For private chats, add the user\n      if (chat.type === 'private' && chat.id) {\n        const userId = createUniqueUuid(this.runtime, chat.id.toString()) as UUID;\n        entities.push({\n          id: userId,\n          names: [chat.first_name || 'Unknown User'],\n          agentId: this.runtime.agentId,\n          metadata: {\n            telegram: {\n              id: chat.id.toString(),\n              username: chat.username || 'unknown',\n              name: chat.first_name || 'Unknown User',\n            },\n            source: 'telegram',\n          },\n        });\n        this.syncedEntityIds.add(userId);\n      } else if (chat.type === 'group' || chat.type === 'supergroup') {\n        // For groups and supergroups, try to get member information\n        try {\n          // Get chat administrators (this is what's available through the Bot API)\n          const admins = await this.bot?.telegram.getChatAdministrators(chat.id);\n\n          if (admins && admins.length > 0) {\n            for (const admin of admins) {\n              const userId = createUniqueUuid(this.runtime, admin.user.id.toString()) as UUID;\n              entities.push({\n                id: userId,\n                names: [admin.user.first_name || admin.user.username || 'Unknown Admin'],\n                agentId: this.runtime.agentId,\n                metadata: {\n                  telegram: {\n                    id: admin.user.id.toString(),\n                    username: admin.user.username || 'unknown',\n                    name: admin.user.first_name || 'Unknown Admin',\n                    isAdmin: true,\n                    adminTitle:\n                      admin.custom_title || (admin.status === 'creator' ? 'Owner' : 'Admin'),\n                  },\n                  source: 'telegram',\n                  roles: [admin.status === 'creator' ? Role.OWNER : Role.ADMIN],\n                },\n              });\n              this.syncedEntityIds.add(userId);\n            }\n          }\n        } catch (error) {\n          logger.warn(`Could not fetch administrators for chat ${chat.id}: ${error}`);\n        }\n      }\n    } catch (error) {\n      logger.error(\n        `Error building standardized entities: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n\n    return entities;\n  }\n\n  /**\n   * Extracts and builds the room object for a forum topic from a message context.\n   * This refactored method can be used both in middleware and when handling new chats.\n   *\n   * @param {Context} ctx - The context of the incoming update\n   * @param {UUID} worldId - The ID of the world the topic belongs to\n   * @returns {Promise<Room | null>} A Promise that resolves with the room or null if not a topic\n   * @private\n   */\n  private async buildForumTopicRoom(ctx: Context, worldId: UUID): Promise<Room | null> {\n    if (!ctx.chat || !ctx.message?.message_thread_id) return null;\n    if (ctx.chat.type !== 'supergroup' || !ctx.chat.is_forum) return null;\n\n    const chat = ctx.chat;\n    const chatId = chat.id.toString();\n    const threadId = ctx.message.message_thread_id.toString();\n    const roomId = createUniqueUuid(this.runtime, `${chatId}-${threadId}`) as UUID;\n\n    try {\n      // Ensure the message object is fully initialized\n      const replyMessage = JSON.parse(JSON.stringify(ctx.message));\n\n      // Default topic name\n      let topicName = `Topic #${threadId}`;\n\n      // Check if forum_topic_created exists directly in the message\n      if (\n        replyMessage &&\n        typeof replyMessage === 'object' &&\n        'forum_topic_created' in replyMessage &&\n        replyMessage.forum_topic_created\n      ) {\n        const topicCreated = replyMessage.forum_topic_created;\n        if (topicCreated && typeof topicCreated === 'object' && 'name' in topicCreated) {\n          topicName = topicCreated.name;\n        }\n      }\n      // Check if forum_topic_created exists in reply_to_message\n      else if (\n        replyMessage &&\n        typeof replyMessage === 'object' &&\n        'reply_to_message' in replyMessage &&\n        replyMessage.reply_to_message &&\n        typeof replyMessage.reply_to_message === 'object' &&\n        'forum_topic_created' in replyMessage.reply_to_message &&\n        replyMessage.reply_to_message.forum_topic_created\n      ) {\n        const topicCreated = replyMessage.reply_to_message.forum_topic_created;\n        if (topicCreated && typeof topicCreated === 'object' && 'name' in topicCreated) {\n          topicName = topicCreated.name;\n        }\n      }\n\n      // Create a room for this topic\n      const room: Room = {\n        id: roomId,\n        name: topicName,\n        source: 'telegram',\n        type: ChannelType.GROUP,\n        channelId: `${chatId}-${threadId}`,\n        serverId: chatId,\n        worldId,\n        metadata: {\n          threadId: threadId,\n          isForumTopic: true,\n          parentChatId: chatId,\n        },\n      };\n\n      return room;\n    } catch (error) {\n      logger.error(\n        `Error building forum topic room: ${error instanceof Error ? error.message : String(error)}`\n      );\n      return null;\n    }\n  }\n\n  static registerSendHandlers(runtime: IAgentRuntime, serviceInstance: TelegramService) {\n    if (serviceInstance && serviceInstance.bot) {\n      runtime.registerSendHandler(\n        'telegram',\n        serviceInstance.handleSendMessage.bind(serviceInstance)\n      );\n      logger.info('[Telegram] Registered send handler.');\n    } else {\n      logger.warn('[Telegram] Cannot register send handler - bot not initialized.');\n    }\n  }\n\n  async handleSendMessage(\n    runtime: IAgentRuntime,\n    target: TargetInfo,\n    content: Content\n  ): Promise<void> {\n    // Check if bot and messageManager are available\n    if (!this.bot || !this.messageManager) {\n      logger.error('[Telegram SendHandler] Bot not initialized - cannot send messages.');\n      throw new Error('Telegram bot is not initialized. Please provide TELEGRAM_BOT_TOKEN.');\n    }\n\n    let chatId: number | string | undefined;\n\n    // Determine the target chat ID\n    if (target.channelId) {\n      // Use channelId directly if provided (might be string like chat_id-thread_id or just chat_id)\n      // We might need to parse this depending on how room IDs are stored vs Telegram IDs\n      chatId = target.channelId;\n    } else if (target.roomId) {\n      // Fallback: Try to use roomId if channelId isn't available\n      // This assumes roomId maps directly to Telegram chat ID or requires lookup\n      // Placeholder - requires logic to map roomId -> telegram chat ID if different\n      const room = await runtime.getRoom(target.roomId);\n      chatId = room?.channelId; // Assuming channelId on Room IS the telegram ID\n      if (!chatId)\n        throw new Error(`Could not resolve Telegram chat ID from roomId ${target.roomId}`);\n    } else if (target.entityId) {\n      // TODO: Need robust way to map entityId (runtime UUID) to Telegram User ID (number)\n      // This might involve checking entity metadata.\n      // For now, this part is non-functional without that mapping.\n      logger.error('[Telegram SendHandler] Sending DMs via entityId not implemented yet.');\n      throw new Error('Sending DMs via entityId is not yet supported for Telegram.');\n      // Example placeholder: const telegramUserId = await getTelegramIdFromEntity(runtime, target.entityId);\n      // chatId = telegramUserId;\n    } else {\n      throw new Error('Telegram SendHandler requires channelId, roomId, or entityId.');\n    }\n\n    if (!chatId) {\n      throw new Error(\n        `Could not determine target Telegram chat ID for target: ${JSON.stringify(target)}`\n      );\n    }\n\n    try {\n      // Use existing MessageManager method, pass chatId and content\n      // Assuming sendMessage handles splitting, markdown, etc.\n      await this.messageManager.sendMessage(chatId, content);\n      logger.info(`[Telegram SendHandler] Message sent to chat ID: ${chatId}`);\n    } catch (error) {\n      logger.error(\n        {\n          target,\n          content,\n        },\n        `[Telegram SendHandler] Error sending message: ${error instanceof Error ? error.message : String(error)}`\n      );\n      throw error;\n    }\n  }\n}\n","import {\n  ChannelType,\n  type Content,\n  EventType,\n  type HandlerCallback,\n  type IAgentRuntime,\n  type Media,\n  type Memory,\n  ModelType,\n  type UUID,\n  createUniqueUuid,\n  logger,\n} from '@elizaos/core';\nimport type { Chat, Message, ReactionType, Update } from '@telegraf/types';\nimport type { Context, NarrowedContext, Telegraf } from 'telegraf';\nimport { Markup } from 'telegraf';\nimport {\n  TelegramContent,\n  TelegramEventTypes,\n  type TelegramMessageReceivedPayload,\n  type TelegramMessageSentPayload,\n  type TelegramReactionReceivedPayload,\n} from './types';\nimport { convertToTelegramButtons, convertMarkdownToTelegram } from './utils';\nimport fs from 'fs';\n/**\n * Enum representing different types of media.\n * @enum { string }\n * @readonly\n */\nexport enum MediaType {\n  PHOTO = 'photo',\n  VIDEO = 'video',\n  DOCUMENT = 'document',\n  AUDIO = 'audio',\n  ANIMATION = 'animation',\n}\n\nconst MAX_MESSAGE_LENGTH = 4096; // Telegram's max message length\n\nconst getChannelType = (chat: Chat): ChannelType => {\n  // Use a switch statement for clarity and exhaustive checks\n  switch (chat.type) {\n    case 'private':\n      return ChannelType.DM;\n    case 'group':\n    case 'supergroup':\n    case 'channel':\n      return ChannelType.GROUP;\n    default:\n      throw new Error(`Unrecognized Telegram chat type: ${(chat as any).type}`);\n  }\n};\n\n/**\n * Class representing a message manager.\n * @class\n */\nexport class MessageManager {\n  public bot: Telegraf<Context>;\n  protected runtime: IAgentRuntime;\n\n  /**\n   * Constructor for creating a new instance of a BotAgent.\n   *\n   * @param {Telegraf<Context>} bot - The Telegraf instance used for interacting with the bot platform.\n   * @param {IAgentRuntime} runtime - The runtime environment for the agent.\n   */\n  constructor(bot: Telegraf<Context>, runtime: IAgentRuntime) {\n    this.bot = bot;\n    this.runtime = runtime;\n  }\n\n  // Process image messages and generate descriptions\n  /**\n   * Process an image from a Telegram message to extract the image URL and description.\n   *\n   * @param {Message} message - The Telegram message object containing the image.\n   * @returns {Promise<{ description: string } | null>} The description of the processed image or null if no image found.\n   */\n  async processImage(message: Message): Promise<{ description: string } | null> {\n    try {\n      let imageUrl: string | null = null;\n\n      logger.info(`Telegram Message: ${JSON.stringify(message, null, 2)}`);\n\n      if ('photo' in message && message.photo?.length > 0) {\n        const photo = message.photo[message.photo.length - 1];\n        const fileLink = await this.bot.telegram.getFileLink(photo.file_id);\n        imageUrl = fileLink.toString();\n      } else if ('document' in message && message.document?.mime_type?.startsWith('image/')) {\n        const fileLink = await this.bot.telegram.getFileLink(message.document.file_id);\n        imageUrl = fileLink.toString();\n      }\n\n      if (imageUrl) {\n        const { title, description } = await this.runtime.useModel(\n          ModelType.IMAGE_DESCRIPTION,\n          imageUrl\n        );\n        return { description: `[Image: ${title}\\n${description}]` };\n      }\n    } catch (error) {\n      console.error('‚ùå Error processing image:', error);\n    }\n\n    return null;\n  }\n\n  // Send long messages in chunks\n  /**\n   * Sends a message in chunks, handling attachments and splitting the message if necessary\n   *\n   * @param {Context} ctx - The context object representing the current state of the bot\n   * @param {TelegramContent} content - The content of the message to be sent\n   * @param {number} [replyToMessageId] - The ID of the message to reply to, if any\n   * @returns {Promise<Message.TextMessage[]>} - An array of TextMessage objects representing the messages sent\n   */\n  async sendMessageInChunks(\n    ctx: Context,\n    content: TelegramContent,\n    replyToMessageId?: number\n  ): Promise<Message.TextMessage[]> {\n    if (content.attachments && content.attachments.length > 0) {\n      content.attachments.map(async (attachment: Media) => {\n        const typeMap: { [key: string]: MediaType } = {\n          'image/gif': MediaType.ANIMATION,\n          image: MediaType.PHOTO,\n          doc: MediaType.DOCUMENT,\n          video: MediaType.VIDEO,\n          audio: MediaType.AUDIO,\n        };\n\n        let mediaType: MediaType | undefined = undefined;\n\n        for (const prefix in typeMap) {\n          if (attachment.contentType?.startsWith(prefix)) {\n            mediaType = typeMap[prefix];\n            break;\n          }\n        }\n\n        if (!mediaType) {\n          throw new Error(\n            `Unsupported Telegram attachment content type: ${attachment.contentType}`\n          );\n        }\n\n        await this.sendMedia(ctx, attachment.url, mediaType, attachment.description);\n      });\n      return [];\n    } else {\n      const chunks = this.splitMessage(content.text ?? '');\n      const sentMessages: Message.TextMessage[] = [];\n\n      const telegramButtons = convertToTelegramButtons(content.buttons ?? []);\n\n      if (!ctx.chat) {\n        logger.error('sendMessageInChunks: ctx.chat is undefined');\n        return [];\n      }\n      await ctx.telegram.sendChatAction(ctx.chat.id, 'typing');\n\n      for (let i = 0; i < chunks.length; i++) {\n        const chunk = convertMarkdownToTelegram(chunks[i]);\n        if (!ctx.chat) {\n          logger.error('sendMessageInChunks loop: ctx.chat is undefined');\n          continue;\n        }\n        const sentMessage = (await ctx.telegram.sendMessage(ctx.chat.id, chunk, {\n          reply_parameters:\n            i === 0 && replyToMessageId ? { message_id: replyToMessageId } : undefined,\n          parse_mode: 'MarkdownV2',\n          ...Markup.inlineKeyboard(telegramButtons),\n        })) as Message.TextMessage;\n\n        sentMessages.push(sentMessage);\n      }\n\n      return sentMessages;\n    }\n  }\n\n  /**\n   * Sends media to a chat using the Telegram API.\n   *\n   * @param {Context} ctx - The context object containing information about the current chat.\n   * @param {string} mediaPath - The path to the media to be sent, either a URL or a local file path.\n   * @param {MediaType} type - The type of media being sent (PHOTO, VIDEO, DOCUMENT, AUDIO, or ANIMATION).\n   * @param {string} [caption] - Optional caption for the media being sent.\n   *\n   * @returns {Promise<void>} A Promise that resolves when the media is successfully sent.\n   */\n  async sendMedia(\n    ctx: Context,\n    mediaPath: string,\n    type: MediaType,\n    caption?: string\n  ): Promise<void> {\n    try {\n      const isUrl = /^(http|https):\\/\\//.test(mediaPath);\n      const sendFunctionMap: Record<MediaType, Function> = {\n        [MediaType.PHOTO]: ctx.telegram.sendPhoto.bind(ctx.telegram),\n        [MediaType.VIDEO]: ctx.telegram.sendVideo.bind(ctx.telegram),\n        [MediaType.DOCUMENT]: ctx.telegram.sendDocument.bind(ctx.telegram),\n        [MediaType.AUDIO]: ctx.telegram.sendAudio.bind(ctx.telegram),\n        [MediaType.ANIMATION]: ctx.telegram.sendAnimation.bind(ctx.telegram),\n      };\n\n      const sendFunction = sendFunctionMap[type];\n\n      if (!sendFunction) {\n        throw new Error(`Unsupported media type: ${type}`);\n      }\n\n      if (!ctx.chat) {\n        throw new Error('sendMedia: ctx.chat is undefined');\n      }\n\n      if (isUrl) {\n        // Handle HTTP URLs\n        await sendFunction(ctx.chat.id, mediaPath, { caption });\n      } else {\n        // Handle local file paths\n        if (!fs.existsSync(mediaPath)) {\n          throw new Error(`File not found at path: ${mediaPath}`);\n        }\n\n        const fileStream = fs.createReadStream(mediaPath);\n\n        try {\n          if (!ctx.chat) {\n            throw new Error('sendMedia (file): ctx.chat is undefined');\n          }\n          await sendFunction(ctx.chat.id, { source: fileStream }, { caption });\n        } finally {\n          fileStream.destroy();\n        }\n      }\n\n      logger.info(\n        `${type.charAt(0).toUpperCase() + type.slice(1)} sent successfully: ${mediaPath}`\n      );\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      logger.error(\n        { originalError: error },\n        `Failed to send ${type}. Path: ${mediaPath}. Error: ${errorMessage}`\n      );\n      throw error;\n    }\n  }\n\n  // Split message into smaller parts\n  /**\n   * Splits a given text into an array of strings based on the maximum message length.\n   *\n   * @param {string} text - The text to split into chunks.\n   * @returns {string[]} An array of strings with each element representing a chunk of the original text.\n   */\n  private splitMessage(text: string): string[] {\n    const chunks: string[] = [];\n    if (!text) return chunks;\n    let currentChunk = '';\n\n    const lines = text.split('\\n');\n    for (const line of lines) {\n      if (currentChunk.length + line.length + 1 <= MAX_MESSAGE_LENGTH) {\n        currentChunk += (currentChunk ? '\\n' : '') + line;\n      } else {\n        if (currentChunk) chunks.push(currentChunk);\n        currentChunk = line;\n      }\n    }\n\n    if (currentChunk) chunks.push(currentChunk);\n    return chunks;\n  }\n\n  // Main handler for incoming messages\n  /**\n   * Handle incoming messages from Telegram and process them accordingly.\n   * @param {Context} ctx - The context object containing information about the message.\n   * @returns {Promise<void>}\n   */\n  public async handleMessage(ctx: Context): Promise<void> {\n    // Type guard to ensure message exists\n    if (!ctx.message || !ctx.from) return;\n\n    const message = ctx.message as Message.TextMessage;\n\n    try {\n      // Convert IDs to UUIDs\n      const entityId = createUniqueUuid(this.runtime, ctx.from.id.toString()) as UUID;\n\n      const threadId =\n        'is_topic_message' in message && message.is_topic_message\n          ? message.message_thread_id?.toString()\n          : undefined;\n\n      // Add null check for ctx.chat\n      if (!ctx.chat) {\n        logger.error('handleMessage: ctx.chat is undefined');\n        return;\n      }\n      // Generate room ID based on whether this is in a forum topic\n      const telegramRoomid = threadId ? `${ctx.chat.id}-${threadId}` : ctx.chat.id.toString();\n      const roomId = createUniqueUuid(this.runtime, telegramRoomid) as UUID;\n\n      // Get message ID (unique to channel)\n      const messageId = createUniqueUuid(this.runtime, message?.message_id?.toString());\n\n      // Handle images\n      const imageInfo = await this.processImage(message);\n\n      // Get message text - use type guards for safety\n      let messageText = '';\n      if ('text' in message && message.text) {\n        messageText = message.text;\n      } else if ('caption' in message && message.caption) {\n        messageText = message.caption as string;\n      }\n\n      // Combine text and image description\n      const fullText = imageInfo ? `${messageText} ${imageInfo.description}` : messageText;\n      if (!fullText) return;\n\n      // Get chat type and determine channel type\n      const chat = message.chat as Chat;\n      const channelType = getChannelType(chat);\n\n      const sourceId = createUniqueUuid(this.runtime, '' + chat.id);\n\n      await this.runtime.ensureConnection({\n        entityId,\n        roomId,\n        userName: ctx.from.username,\n        name: ctx.from.first_name,\n        source: 'telegram',\n        channelId: telegramRoomid,\n        serverId: undefined,\n        type: channelType,\n        worldId: createUniqueUuid(this.runtime, roomId) as UUID,\n        worldName: telegramRoomid,\n      });\n\n      // Create the memory object\n      const memory: Memory = {\n        id: messageId,\n        entityId,\n        agentId: this.runtime.agentId,\n        roomId,\n        content: {\n          text: fullText,\n          // attachments?\n          source: 'telegram',\n          // url?\n          channelType: channelType,\n          inReplyTo:\n            'reply_to_message' in message && message.reply_to_message\n              ? createUniqueUuid(this.runtime, message.reply_to_message.message_id.toString())\n              : undefined,\n        },\n        metadata: {\n          entityName: ctx.from.first_name,\n          entityUserName: ctx.from.username,\n          fromBot: ctx.from.is_bot,\n          // include very technical/exact reference to this user for security reasons\n          // don't remove or change this, spartan needs this\n          fromId: chat.id,\n          sourceId,\n          // why message? all Memories contain content (which is basically a message)\n          // what are the other types? see MemoryType\n          type: 'message', // MemoryType.MESSAGE\n          // scope: `shared`, `private`, or `room`\n        },\n        createdAt: message.date * 1000,\n      };\n\n      // Create callback for handling responses\n      const callback: HandlerCallback = async (content: Content, _files?: string[]) => {\n        try {\n          // If response is from reasoning do not send it.\n          if (!content.text) return [];\n\n          let sentMessages: boolean | Message.TextMessage[] = false;\n          // channelType target === 'telegram'\n          if (content?.channelType === 'DM') {\n            sentMessages = [];\n            if (ctx.from) {\n              // FIXME split on 4096 chars\n              const res = await this.bot.telegram.sendMessage(ctx.from.id, content.text);\n              sentMessages.push(res);\n            }\n          } else {\n            sentMessages = await this.sendMessageInChunks(ctx, content, message.message_id);\n          }\n\n          if (!Array.isArray(sentMessages)) return [];\n\n          const memories: Memory[] = [];\n          for (let i = 0; i < sentMessages.length; i++) {\n            const sentMessage = sentMessages[i];\n\n            const responseMemory: Memory = {\n              id: createUniqueUuid(this.runtime, sentMessage.message_id.toString()),\n              entityId: this.runtime.agentId,\n              agentId: this.runtime.agentId,\n              roomId,\n              content: {\n                ...content,\n                source: 'telegram',\n                text: sentMessage.text,\n                inReplyTo: messageId,\n                channelType: channelType,\n              },\n              createdAt: sentMessage.date * 1000,\n            };\n\n            await this.runtime.createMemory(responseMemory, 'messages');\n            memories.push(responseMemory);\n          }\n\n          return memories;\n        } catch (error) {\n          logger.error({ error }, 'Error in message callback');\n          return [];\n        }\n      };\n\n      // Let the bootstrap plugin handle the message\n      this.runtime.emitEvent(EventType.MESSAGE_RECEIVED, {\n        runtime: this.runtime,\n        message: memory,\n        callback,\n        source: 'telegram',\n      });\n\n      // Also emit the platform-specific event\n      this.runtime.emitEvent(TelegramEventTypes.MESSAGE_RECEIVED, {\n        runtime: this.runtime,\n        message: memory,\n        callback,\n        source: 'telegram',\n        ctx,\n        originalMessage: message,\n      } as TelegramMessageReceivedPayload);\n    } catch (error) {\n      logger.error(\n        {\n          error,\n          chatId: ctx.chat?.id,\n          messageId: ctx.message?.message_id,\n          from: ctx.from?.username || ctx.from?.id,\n        },\n        'Error handling Telegram message'\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * Handles the reaction event triggered by a user reacting to a message.\n   * @param {NarrowedContext<Context<Update>, Update.MessageReactionUpdate>} ctx The context of the message reaction update\n   * @returns {Promise<void>} A Promise that resolves when the reaction handling is complete\n   */\n  public async handleReaction(\n    ctx: NarrowedContext<Context<Update>, Update.MessageReactionUpdate>\n  ): Promise<void> {\n    // Ensure we have the necessary data\n    if (!ctx.update.message_reaction || !ctx.from) return;\n\n    const reaction = ctx.update.message_reaction;\n    const reactedToMessageId = reaction.message_id;\n\n    const originalMessagePlaceholder: Partial<Message> = {\n      message_id: reactedToMessageId,\n      chat: reaction.chat,\n      from: ctx.from,\n      date: Math.floor(Date.now() / 1000),\n    };\n\n    const reactionType = reaction.new_reaction[0].type;\n    const reactionEmoji = (reaction.new_reaction[0] as ReactionType).type; // Assuming ReactionType has 'type' for emoji\n\n    try {\n      const entityId = createUniqueUuid(this.runtime, ctx.from.id.toString()) as UUID;\n      const roomId = createUniqueUuid(this.runtime, ctx.chat.id.toString());\n\n      const reactionId = createUniqueUuid(\n        this.runtime,\n        `${reaction.message_id}-${ctx.from.id}-${Date.now()}`\n      );\n\n      // Create reaction memory\n      const memory: Memory = {\n        id: reactionId,\n        entityId,\n        agentId: this.runtime.agentId,\n        roomId,\n        content: {\n          channelType: getChannelType(reaction.chat as Chat),\n          text: `Reacted with: ${reactionType === 'emoji' ? reactionEmoji : reactionType}`,\n          source: 'telegram',\n          inReplyTo: createUniqueUuid(this.runtime, reaction.message_id.toString()),\n        },\n        createdAt: Date.now(),\n      };\n\n      // Create callback for handling reaction responses\n      const callback: HandlerCallback = async (content: Content) => {\n        try {\n          // Add null check for content.text\n          const replyText = content.text ?? '';\n          const sentMessage = await ctx.reply(replyText);\n          const responseMemory: Memory = {\n            id: createUniqueUuid(this.runtime, sentMessage.message_id.toString()),\n            entityId: this.runtime.agentId,\n            agentId: this.runtime.agentId,\n            roomId,\n            content: {\n              ...content,\n              inReplyTo: reactionId,\n            },\n            createdAt: sentMessage.date * 1000,\n          };\n          return [responseMemory];\n        } catch (error) {\n          logger.error({ error }, 'Error in reaction callback');\n          return [];\n        }\n      };\n\n      // Let the bootstrap plugin handle the reaction\n      this.runtime.emitEvent(EventType.REACTION_RECEIVED, {\n        runtime: this.runtime,\n        message: memory,\n        callback,\n        source: 'telegram',\n        ctx,\n        originalMessage: originalMessagePlaceholder as Message, // Cast needed due to placeholder\n        reactionString: reactionType === 'emoji' ? reactionEmoji : reactionType,\n        originalReaction: reaction.new_reaction[0] as ReactionType,\n      } as TelegramReactionReceivedPayload);\n\n      // Also emit the platform-specific event\n      this.runtime.emitEvent(TelegramEventTypes.REACTION_RECEIVED, {\n        runtime: this.runtime,\n        message: memory,\n        callback,\n        source: 'telegram',\n        ctx,\n        originalMessage: originalMessagePlaceholder as Message, // Cast needed due to placeholder\n        reactionString: reactionType === 'emoji' ? reactionEmoji : reactionType,\n        originalReaction: reaction.new_reaction[0] as ReactionType,\n      } as TelegramReactionReceivedPayload);\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      logger.error(\n        {\n          error: errorMessage,\n          originalError: error,\n        },\n        'Error handling reaction'\n      );\n    }\n  }\n\n  /**\n   * Sends a message to a Telegram chat and emits appropriate events\n   * @param {number | string} chatId - The Telegram chat ID to send the message to\n   * @param {Content} content - The content to send\n   * @param {number} [replyToMessageId] - Optional message ID to reply to\n   * @returns {Promise<Message.TextMessage[]>} The sent messages\n   */\n  public async sendMessage(\n    chatId: number | string,\n    content: Content,\n    replyToMessageId?: number\n  ): Promise<Message.TextMessage[]> {\n    try {\n      // Create a context-like object for sending\n      const ctx = {\n        chat: { id: chatId },\n        telegram: this.bot.telegram,\n      };\n\n      const sentMessages = await this.sendMessageInChunks(\n        ctx as Context,\n        content,\n        replyToMessageId\n      );\n\n      if (!sentMessages?.length) return [];\n\n      // Create group ID\n      const roomId = createUniqueUuid(this.runtime, chatId.toString());\n\n      // Create memories for the sent messages\n      const memories: Memory[] = [];\n      for (const sentMessage of sentMessages) {\n        const memory: Memory = {\n          id: createUniqueUuid(this.runtime, sentMessage.message_id.toString()),\n          entityId: this.runtime.agentId,\n          agentId: this.runtime.agentId,\n          roomId,\n          content: {\n            ...content,\n            text: sentMessage.text,\n            source: 'telegram',\n            channelType: getChannelType({\n              id: typeof chatId === 'string' ? Number.parseInt(chatId, 10) : chatId,\n              type: 'private', // Default to private, will be overridden if in context\n            } as Chat),\n          },\n          createdAt: sentMessage.date * 1000,\n        };\n\n        await this.runtime.createMemory(memory, 'messages');\n        memories.push(memory);\n      }\n\n      // Emit both generic and platform-specific message sent events\n      this.runtime.emitEvent(EventType.MESSAGE_SENT, {\n        runtime: this.runtime,\n        message: {\n          content: content,\n        },\n        roomId,\n        source: 'telegram',\n      });\n\n      // Also emit platform-specific event\n      this.runtime.emitEvent(TelegramEventTypes.MESSAGE_SENT, {\n        originalMessages: sentMessages,\n        chatId,\n      } as TelegramMessageSentPayload);\n\n      return sentMessages;\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      logger.error(\n        {\n          error: errorMessage,\n          originalError: error,\n        },\n        'Error sending message to Telegram'\n      );\n      return [];\n    }\n  }\n}\n","import { Markup } from 'telegraf';\nimport { InlineKeyboardButton } from '@telegraf/types';\nimport { Button } from './types';\n\n// A list of Telegram MarkdownV2 reserved characters that must be escaped\nconst TELEGRAM_RESERVED_REGEX = /([_*[\\]()~`>#+\\-=|{}.!\\\\])/g;\n\n/**\n * Escapes plain text for Telegram MarkdownV2.\n * (Any character in 1‚Äì126 that is reserved is prefixed with a backslash.)\n */\nfunction escapePlainText(text: string): string {\n  if (!text) return '';\n  return text.replace(TELEGRAM_RESERVED_REGEX, '\\\\$1');\n}\n\n/**\n * Escapes plain text line‚Äêby‚Äìline while preserving any leading blockquote markers.\n */\nfunction escapePlainTextPreservingBlockquote(text: string): string {\n  if (!text) return '';\n  return text\n    .split('\\n')\n    .map((line) => {\n      // If the line begins with one or more \">\" (and optional space),\n      // leave that part unescaped.\n      const match = line.match(/^(>+\\s?)(.*)$/);\n      if (match) {\n        return match[1] + escapePlainText(match[2]);\n      }\n      return escapePlainText(line);\n    })\n    .join('\\n');\n}\n\n/**\n * Escapes code inside inline or pre-formatted code blocks.\n * Telegram requires that inside code blocks all ` and \\ characters are escaped.\n */\nfunction escapeCode(text: string): string {\n  if (!text) return '';\n  return text.replace(/([`\\\\])/g, '\\\\$1');\n}\n\n/**\n * Escapes a URL for inline links:\n * inside the URL, only \")\" and \"\\\" need to be escaped.\n */\nfunction escapeUrl(url: string): string {\n  if (!url) return '';\n  return url.replace(/([)\\\\])/g, '\\\\$1');\n}\n\n/**\n * This function converts standard markdown to Telegram MarkdownV2.\n *\n * In addition to processing code blocks, inline code, links, bold, strikethrough, and italic,\n * it converts any header lines (those starting with one or more `#`) to bold text.\n *\n * Note: This solution uses a sequence of regex‚Äêreplacements and placeholders.\n * It makes assumptions about non‚Äìnested formatting and does not cover every edge case.\n */\nexport function convertMarkdownToTelegram(markdown: string): string {\n  // We will temporarily replace recognized markdown tokens with placeholders.\n  // Each placeholder is a string like \"\\u0000{index}\\u0000\".\n  const replacements: string[] = [];\n  function storeReplacement(formatted: string): string {\n    const placeholder = `\\u0000${replacements.length}\\u0000`;\n    replacements.push(formatted);\n    return placeholder;\n  }\n\n  let converted = markdown;\n\n  // 1. Fenced code blocks (```...```)\n  //    Matches an optional language (letters only) and then any content until the closing ```\n  converted = converted.replace(/```(\\w+)?\\n([\\s\\S]*?)```/g, (_match, lang, code) => {\n    const escapedCode = escapeCode(code);\n    const formatted = '```' + (lang || '') + '\\n' + escapedCode + '```';\n    return storeReplacement(formatted);\n  });\n\n  // 2. Inline code (`...`)\n  converted = converted.replace(/`([^`]+)`/g, (_match, code) => {\n    const escapedCode = escapeCode(code);\n    const formatted = '`' + escapedCode + '`';\n    return storeReplacement(formatted);\n  });\n\n  // 3. Links: [link text](url)\n  converted = converted.replace(\n    /$begin:math:display$([^$end:math:display$]+)]$begin:math:text$([^)]+)$end:math:text$/g,\n    (_match, text, url) => {\n      // For link text we escape as plain text.\n      const formattedText = escapePlainText(text);\n      const escapedURL = escapeUrl(url);\n      const formatted = `[${formattedText}](${escapedURL})`;\n      return storeReplacement(formatted);\n    }\n  );\n\n  // 4. Bold text: standard markdown bold **text**\n  //    Telegram bold is delimited by single asterisks: *text*\n  converted = converted.replace(/\\*\\*([^*]+)\\*\\*/g, (_match, content) => {\n    const formattedContent = escapePlainText(content);\n    const formatted = `*${formattedContent}*`;\n    return storeReplacement(formatted);\n  });\n\n  // 5. Strikethrough: standard markdown uses ~~text~~,\n  //    while Telegram uses ~text~\n  converted = converted.replace(/~~([^~]+)~~/g, (_match, content) => {\n    const formattedContent = escapePlainText(content);\n    const formatted = `~${formattedContent}~`;\n    return storeReplacement(formatted);\n  });\n\n  // 6. Italic text:\n  //    Standard markdown italic can be written as either *text* or _text_.\n  //    In Telegram MarkdownV2 italic must be delimited by underscores.\n  //    Process asterisk-based italic first.\n  //    (Using negative lookbehind/lookahead to avoid matching bold **)\n  converted = converted.replace(/(?<!\\*)\\*([^*\\n]+)\\*(?!\\*)/g, (_match, content) => {\n    const formattedContent = escapePlainText(content);\n    const formatted = `_${formattedContent}_`;\n    return storeReplacement(formatted);\n  });\n  //    Then underscore-based italic.\n  converted = converted.replace(/_([^_\\n]+)_/g, (_match, content) => {\n    const formattedContent = escapePlainText(content);\n    const formatted = `_${formattedContent}_`;\n    return storeReplacement(formatted);\n  });\n\n  // 7. Headers: Convert markdown headers (lines starting with '#' characters)\n  //    to bold text. This avoids unescaped '#' characters (which crash Telegram)\n  //    by removing them and wrapping the rest of the line in bold markers.\n  converted = converted.replace(/^(#{1,6})\\s*(.*)$/gm, (_match, _hashes, headerContent: string) => {\n    // Remove any trailing whitespace and escape the header text.\n    const formatted = `*${escapePlainText(headerContent.trim())}*`;\n    return storeReplacement(formatted);\n  });\n\n  // Define the placeholder marker as a string constant\n  const NULL_CHAR = String.fromCharCode(0);\n  const PLACEHOLDER_PATTERN = new RegExp(`(${NULL_CHAR}\\\\d+${NULL_CHAR})`, 'g');\n  const PLACEHOLDER_TEST = new RegExp(`^${NULL_CHAR}\\\\d+${NULL_CHAR}$`);\n  const PLACEHOLDER_REPLACE = new RegExp(`${NULL_CHAR}(\\\\d+)${NULL_CHAR}`, 'g');\n\n  const finalEscaped = converted\n    .split(PLACEHOLDER_PATTERN)\n    .map((segment) => {\n      // If the segment is a placeholder (matches the pattern), leave it untouched.\n      if (PLACEHOLDER_TEST.test(segment)) {\n        return segment;\n      } else {\n        // Otherwise, escape it while preserving any leading blockquote markers.\n        return escapePlainTextPreservingBlockquote(segment);\n      }\n    })\n    .join('');\n\n  // Finally, substitute back all placeholders with their preformatted content.\n  const finalResult = finalEscaped.replace(PLACEHOLDER_REPLACE, (_, index) => {\n    return replacements[parseInt(index)];\n  });\n\n  return finalResult;\n}\n\n/**\n * Splits a message into chunks that fit within Telegram's message length limit\n */\n/**\n * Splits a text message into chunks based on a maximum length for each chunk.\n *\n * @param {string} text - The text message to split.\n * @param {number} maxLength - The maximum length for each chunk (default is 4096).\n * @returns {string[]} An array containing the text message split into chunks.\n */\nexport function splitMessage(text: string, maxLength = 4096): string[] {\n  const chunks: string[] = [];\n  if (!text) return chunks;\n  let currentChunk = '';\n\n  const lines = text.split('\\n');\n  for (const line of lines) {\n    if (currentChunk.length + line.length + 1 <= maxLength) {\n      currentChunk += (currentChunk ? '\\n' : '') + line;\n    } else {\n      if (currentChunk) chunks.push(currentChunk);\n      currentChunk = line;\n    }\n  }\n\n  if (currentChunk) chunks.push(currentChunk);\n  return chunks;\n}\n\n/**\n * Converts Eliza buttons into Telegram buttons\n * @param {Button[]} buttons - The buttons from Eliza content\n * @returns {InlineKeyboardButton[]} Array of Telegram buttons\n */\nexport function convertToTelegramButtons(buttons?: Button[] | null): InlineKeyboardButton[] {\n  if (!buttons) return [];\n  return buttons.map((button: Button) => {\n    switch (button.kind) {\n      case 'login':\n        return Markup.button.login(button.text, button.url);\n      case 'url':\n        return Markup.button.url(button.text, button.url);\n    }\n  });\n}\n","import { type IAgentRuntime, type TestSuite, logger } from '@elizaos/core';\nimport type { Chat, User } from '@telegraf/types';\nimport type { Telegraf } from 'telegraf';\nimport type { Context } from 'telegraf';\nimport type { MessageManager } from './messageManager';\nimport type { TelegramService } from './service';\nimport type { TelegramContent } from './types';\n\nconst TEST_IMAGE_URL =\n  'https://github.com/elizaOS/awesome-eliza/blob/main/assets/eliza-logo.jpg?raw=true';\n\n/**\n * Represents a test suite for testing Telegram functionality.\n *\n * This test suite includes methods to initialize and validate a Telegram bot connection,\n * send basic text messages to a Telegram chat, send text messages with image attachments,\n * handle and process incoming Telegram messages, and process and validate image attachments\n * in incoming messages.\n *\n * @implements {TestSuite}\n */\n\nexport class TelegramTestSuite implements TestSuite {\n  name = 'telegram';\n  private telegramClient: TelegramService | null = null;\n  private bot: Telegraf<Context> | null = null;\n  private messageManager: MessageManager | null = null;\n  tests: { name: string; fn: (runtime: IAgentRuntime) => Promise<void> }[];\n\n  /**\n   * Constructor for initializing a set of test cases for a Telegram bot.\n   *\n   * @constructor\n   * @property {Array<Object>} tests - An array of test cases with name and corresponding test functions.\n   * @property {string} tests.name - The name of the test case.\n   * @property {function} tests.fn - The test function to be executed.\n   */\n  constructor() {\n    this.tests = [\n      {\n        name: 'Initialize and Validate Telegram Bot Connection',\n        fn: this.testCreatingTelegramBot.bind(this),\n      },\n      {\n        name: 'Send Basic Text Message to Telegram Chat',\n        fn: this.testSendingTextMessage.bind(this),\n      },\n      {\n        name: 'Send Text Message with an Image Attachment',\n        fn: this.testSendingMessageWithAttachment.bind(this),\n      },\n      {\n        name: 'Handle and Process Incoming Telegram Messages',\n        fn: this.testHandlingMessage.bind(this),\n      },\n      {\n        name: 'Process and Validate Image Attachments in Incoming Messages',\n        fn: this.testProcessingImages.bind(this),\n      },\n    ];\n  }\n\n  /**\n   * Retrieves the Telegram test chat ID from environment variables.\n   *\n   * Reference on getting the Telegram chat ID:\n   * https://stackoverflow.com/a/32572159\n   */\n  /**\n   * Validates the chat ID by checking if it is set in the runtime settings or environment variables.\n   * If not set, an error is thrown with a message instructing to provide a valid chat ID.\n   * @param {IAgentRuntime} runtime - The runtime object that provides access to the settings and environment variables.\n   * @throws {Error} If TELEGRAM_TEST_CHAT_ID is not set in the runtime settings or environment variables.\n   * @returns {string} The validated chat ID.\n   */\n  validateChatId(runtime: IAgentRuntime) {\n    const testChatId =\n      runtime.getSetting('TELEGRAM_TEST_CHAT_ID') || process.env.TELEGRAM_TEST_CHAT_ID;\n    if (!testChatId) {\n      throw new Error(\n        'TELEGRAM_TEST_CHAT_ID is not set. Please provide a valid chat ID in the environment variables.'\n      );\n    }\n    return testChatId;\n  }\n\n  async getChatInfo(runtime: IAgentRuntime): Promise<Context['chat']> {\n    try {\n      const chatId = this.validateChatId(runtime);\n      if (!this.bot) {\n        throw new Error('Bot is not initialized.');\n      }\n      const chat = await this.bot.telegram.getChat(chatId);\n      logger.log(`Fetched real chat: ${JSON.stringify(chat)}`);\n      return chat;\n    } catch (error) {\n      throw new Error(`Error fetching real Telegram chat: ${error}`);\n    }\n  }\n\n  async testCreatingTelegramBot(runtime: IAgentRuntime) {\n    this.telegramClient = runtime.getService('telegram') as TelegramService;\n    if (!this.telegramClient || !this.telegramClient.messageManager) {\n      throw new Error(\n        'Telegram service or message manager not initialized - check TELEGRAM_BOT_TOKEN'\n      );\n    }\n    this.bot = this.telegramClient.messageManager.bot;\n    this.messageManager = this.telegramClient.messageManager;\n    logger.debug('Telegram bot initialized successfully.');\n  }\n\n  async testSendingTextMessage(runtime: IAgentRuntime) {\n    try {\n      if (!this.bot) throw new Error('Bot not initialized.');\n\n      const chatId = this.validateChatId(runtime);\n      await this.bot.telegram.sendMessage(chatId, 'Testing Telegram message!');\n      logger.debug('Message sent successfully.');\n    } catch (error) {\n      throw new Error(`Error sending Telegram message: ${error}`);\n    }\n  }\n\n  async testSendingMessageWithAttachment(runtime: IAgentRuntime) {\n    try {\n      if (!this.messageManager) throw new Error('MessageManager not initialized.');\n      if (!this.bot) throw new Error('Bot not initialized.');\n\n      const chat = await this.getChatInfo(runtime);\n      const mockContext: Partial<Context> = {\n        chat,\n        from: { id: 123, username: 'TestUser' } as User,\n        telegram: this.bot.telegram,\n      };\n\n      const messageContent = {\n        text: 'Here is an image attachment:',\n        attachments: [\n          {\n            id: '123',\n            title: 'Sample Image',\n            source: TEST_IMAGE_URL,\n            text: 'Sample Image',\n            url: TEST_IMAGE_URL,\n            contentType: 'image/png',\n            description: 'Sample Image',\n          },\n        ],\n      };\n\n      await this.messageManager.sendMessageInChunks(\n        mockContext as Context,\n        messageContent as TelegramContent\n      );\n\n      logger.success('Message with image attachment sent successfully.');\n    } catch (error) {\n      throw new Error(`Error sending Telegram message with attachment: ${error}`);\n    }\n  }\n\n  async testHandlingMessage(runtime: IAgentRuntime) {\n    try {\n      if (!this.bot) throw new Error('Bot not initialized.');\n      if (!this.messageManager) throw new Error('MessageManager not initialized.');\n\n      const chat = await this.getChatInfo(runtime);\n      const mockContext: Partial<Context> = {\n        chat,\n        from: {\n          id: 123,\n          username: 'TestUser',\n          is_bot: false,\n          first_name: 'Test',\n          last_name: 'User',\n        } as User,\n        message: {\n          message_id: undefined,\n          text: `@${this.bot.botInfo?.username}! Hello!`,\n          date: Math.floor(Date.now() / 1000),\n          chat,\n        } as any,\n        telegram: this.bot.telegram,\n      };\n\n      try {\n        await this.messageManager.handleMessage(mockContext as Context);\n      } catch (error) {\n        throw new Error(`Error handling Telegram message: ${error}`);\n      }\n    } catch (error) {\n      throw new Error(`Error handling Telegram message: ${error}`);\n    }\n  }\n\n  async testProcessingImages(runtime: IAgentRuntime) {\n    try {\n      if (!this.bot) throw new Error('Bot not initialized.');\n      if (!this.messageManager) throw new Error('MessageManager not initialized.');\n\n      const chatId = this.validateChatId(runtime);\n      const fileId = await this.getFileId(chatId, TEST_IMAGE_URL);\n\n      const mockMessage = {\n        message_id: 12345,\n        chat: { id: chatId, type: 'private' } as Chat,\n        date: Math.floor(Date.now() / 1000),\n        photo: [\n          {\n            file_id: fileId,\n            file_unique_id: `unique_${fileId}`,\n            width: 100,\n            height: 100,\n          },\n        ],\n        text: `@${this.bot.botInfo?.username}!`,\n      };\n\n      const result = await this.messageManager.processImage(mockMessage as any);\n      if (!result || !result.description) {\n        throw new Error('Error processing Telegram image or description not found');\n      }\n      const { description } = result;\n      logger.log(`Processing Telegram image successfully: ${description}`);\n    } catch (error) {\n      throw new Error(`Error processing Telegram image: ${error}`);\n    }\n  }\n\n  async getFileId(chatId: string, imageUrl: string) {\n    try {\n      if (!this.bot) {\n        throw new Error('Bot is not initialized.');\n      }\n      const message = await this.bot.telegram.sendPhoto(chatId, imageUrl);\n      if (!message.photo || message.photo.length === 0) {\n        throw new Error('No photo received in the message response.');\n      }\n      return message.photo[message.photo.length - 1].file_id;\n    } catch (error) {\n      logger.error({ error }, `Error sending image: ${error}`);\n      throw error;\n    }\n  }\n}\n","import type { Plugin } from '@elizaos/core';\nimport { TELEGRAM_SERVICE_NAME } from './constants';\nimport { TelegramService } from './service';\nimport { TelegramTestSuite } from './tests';\nimport { MessageManager } from './messageManager';\n\nconst telegramPlugin: Plugin = {\n  name: TELEGRAM_SERVICE_NAME,\n  description: 'Telegram client plugin',\n  services: [TelegramService],\n  tests: [new TelegramTestSuite()],\n};\n\nexport { TelegramService, MessageManager };\nexport default telegramPlugin;\n"],"mappings":"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","names":["ChannelType","EventType","createUniqueUuid","logger","Markup","Markup","logger","createUniqueUuid","ChannelType","EventType","logger"]}