{"version":3,"sources":["../src/index.ts","../src/utils.ts"],"sourcesContent":["import { anthropic } from '@ai-sdk/anthropic';\nimport type {\n  GenerateTextParams,\n  IAgentRuntime,\n  ObjectGenerationParams,\n  Plugin,\n} from '@elizaos/core';\nimport { ModelType, logger } from '@elizaos/core';\nimport { generateText } from 'ai';\nimport { ensureReflectionProperties, extractAndParseJSON } from './utils';\n\n/**\n * Retrieves a configuration setting from the runtime, falling back to environment variables or a default value if not found.\n *\n * @param key - The name of the setting to retrieve.\n * @param defaultValue - The value to return if the setting is not found in the runtime or environment.\n * @returns The resolved setting value, or {@link defaultValue} if not found.\n */\nfunction getSetting(\n  runtime: IAgentRuntime,\n  key: string,\n  defaultValue?: string\n): string | undefined {\n  return runtime.getSetting(key) ?? process.env[key] ?? defaultValue;\n}\n\n/**\n * Helper function to get the API key for Anthropic\n *\n * @param runtime The runtime context\n * @returns The configured API key\n */\nfunction getApiKey(runtime: IAgentRuntime): string | undefined {\n  return getSetting(runtime, 'ANTHROPIC_API_KEY');\n}\n\n/**\n * Helper function to get the experimental telemetry setting\n *\n * @param runtime The runtime context\n * @returns Whether experimental telemetry is enabled\n */\nfunction getExperimentalTelemetry(runtime: IAgentRuntime): boolean {\n  const setting = getSetting(runtime, 'ANTHROPIC_EXPERIMENTAL_TELEMETRY', 'false');\n  const normalizedSetting = String(setting).toLowerCase();\n  const result = normalizedSetting === 'true';\n  return result;\n}\n\n/**\n * Ensures that the Anthropic API key is available in the runtime or environment.\n * Throws an error if the API key is missing.\n *\n * @param runtime - The agent runtime environment to check for settings.\n */\nfunction ensureAnthropicAPIKeyExists(runtime: IAgentRuntime) {\n  const apiKey = getApiKey(runtime);\n  if (!apiKey) {\n    throw new Error(\n      'ANTHROPIC_API_KEY is missing. Please set it in your environment or runtime settings.'\n    );\n  }\n}\n\n/**\n * Plugin for Anthropic.\n *\n * @type {Plugin}\n * @property {string} name - The name of the plugin.\n * @property {string} description - The description of the plugin.\n * @property {Object} config - The configuration object with API keys and model variables.\n * @property {Function} init - Initializes the plugin with the given configuration.\n * @property {Function} models - Contains functions for generating text using small and large models.\n * @property {Function[]} tests - An array of test functions for the plugin.\n */\nexport const anthropicPlugin: Plugin = {\n  name: 'anthropic',\n  description: 'Anthropic plugin (supports text generation only)',\n  config: {\n    ANTHROPIC_API_KEY: process.env.ANTHROPIC_API_KEY,\n    ANTHROPIC_SMALL_MODEL: process.env.ANTHROPIC_SMALL_MODEL,\n    ANTHROPIC_LARGE_MODEL: process.env.ANTHROPIC_LARGE_MODEL,\n    ANTHROPIC_EXPERIMENTAL_TELEMETRY: process.env.ANTHROPIC_EXPERIMENTAL_TELEMETRY,\n  },\n  async init(config: Record<string, string>, runtime: IAgentRuntime) {\n    try {\n      const apiKey = getApiKey(runtime);\n      // If API key is not set, we'll show a warning but continue\n      if (!apiKey) {\n        logger.warn(\n          'ANTHROPIC_API_KEY is not set in environment - Anthropic functionality will be limited'\n        );\n        // Return early without throwing an error\n        return;\n      }\n    } catch (error) {\n      // Convert to warning instead of error\n      logger.warn(\n        `Anthropic plugin configuration issue: ${error} - You need to configure the ANTHROPIC_API_KEY in your environment variables`\n      );\n    }\n  },\n  models: {\n    [ModelType.TEXT_SMALL]: async (\n      runtime,\n      {\n        prompt,\n        stopSequences = [],\n        maxTokens,\n        temperature = 0.7,\n        frequencyPenalty = 0.7,\n        presencePenalty = 0.7,\n      }: GenerateTextParams\n    ) => {\n      ensureAnthropicAPIKeyExists(runtime);\n\n      const smallModel = runtime.getSetting('ANTHROPIC_SMALL_MODEL') ?? 'claude-3-haiku-20240307';\n      // Use provided maxTokens or default based on model\n      if (maxTokens === undefined) {\n        maxTokens = smallModel.includes('-3-') ? 4096 : 8192;\n      }\n      const experimentalTelemetry = getExperimentalTelemetry(runtime);\n\n      logger.log(`[Anthropic] Using TEXT_SMALL model: ${smallModel}`);\n\n      const { text } = await generateText({\n        model: anthropic(smallModel),\n        prompt,\n        // Pass along any system prompt if available.\n        system: runtime.character.system ?? undefined,\n        temperature,\n        maxTokens,\n        stopSequences,\n        frequencyPenalty,\n        presencePenalty,\n        experimental_telemetry: { isEnabled: experimentalTelemetry },\n      });\n      return text;\n    },\n\n    // TEXT_LARGE generation using Anthropics (e.g. using a \"claude-3\" model).\n    [ModelType.TEXT_LARGE]: async (\n      runtime,\n      {\n        prompt,\n        maxTokens = 8192,\n        stopSequences = [],\n        temperature = 0.7,\n        frequencyPenalty = 0.7,\n        presencePenalty = 0.7,\n      }: GenerateTextParams\n    ) => {\n      ensureAnthropicAPIKeyExists(runtime);\n\n      const largeModel = runtime.getSetting('ANTHROPIC_LARGE_MODEL') ?? 'claude-3-5-sonnet-latest';\n      const experimentalTelemetry = getExperimentalTelemetry(runtime);\n\n      logger.log(`[Anthropic] Using TEXT_LARGE model: ${largeModel}`);\n\n      const { text } = await generateText({\n        model: anthropic(largeModel),\n        prompt,\n        system: runtime.character.system ?? undefined,\n        temperature,\n        maxTokens,\n        stopSequences,\n        frequencyPenalty,\n        presencePenalty,\n        experimental_telemetry: { isEnabled: experimentalTelemetry },\n      });\n      return text;\n    },\n\n    [ModelType.OBJECT_SMALL]: async (runtime, params: ObjectGenerationParams) => {\n      ensureAnthropicAPIKeyExists(runtime);\n\n      const smallModel = runtime.getSetting('ANTHROPIC_SMALL_MODEL') ?? 'claude-3-haiku-20240307';\n\n      try {\n        // Check if this is a reflection schema request (has specific format)\n        const isReflection = params.schema?.facts && params.schema.relationships;\n\n        // Build a prompt that asks for JSON output\n        let jsonPrompt = params.prompt;\n\n        // Don't modify the prompt if it already contains explicit JSON formatting instructions\n        if (!jsonPrompt.includes('```json') && !jsonPrompt.includes('respond with valid JSON')) {\n          jsonPrompt +=\n            '\\nPlease respond with valid JSON only, without any explanations, markdown formatting, or additional text.';\n        }\n\n        let systemPrompt = runtime.character.system\n          ? `${runtime.character.system}\\nYou must respond with valid JSON only.`\n          : 'You must respond with valid JSON only.';\n\n        // For reflection schemas, we need a more specific instruction\n        if (isReflection) {\n          systemPrompt +=\n            \" Ensure your response includes 'thought', 'facts', and 'relationships' properties exactly as specified in the prompt.\";\n        } else {\n          systemPrompt += ' No markdown, no code blocks, no explanation text.';\n        }\n\n        // Generate text response that should contain JSON\n        const { text } = await generateText({\n          model: anthropic(smallModel),\n          prompt: jsonPrompt,\n          system: systemPrompt,\n          temperature: params.temperature || 0.2, // Lower temperature for more predictable structured output\n        });\n\n        // Extract and parse JSON from the response with our improved function\n        try {\n          logger.debug('Attempting to parse response from Anthropic model');\n          const jsonObject = extractAndParseJSON(text);\n\n          // Ensure reflection schema has all required properties\n          const processedObject = ensureReflectionProperties(jsonObject, isReflection);\n\n          return processedObject;\n        } catch (parseError) {\n          logger.error(`Failed to parse JSON from Anthropic response: ${parseError}`);\n          logger.error(`Raw response: ${text}`);\n          throw new Error('Invalid JSON returned from Anthropic model');\n        }\n      } catch (error) {\n        logger.error(`Error generating object: ${error}`);\n        throw error;\n      }\n    },\n\n    [ModelType.OBJECT_LARGE]: async (runtime, params: ObjectGenerationParams) => {\n      ensureAnthropicAPIKeyExists(runtime);\n\n      const largeModel = runtime.getSetting('ANTHROPIC_LARGE_MODEL') ?? 'claude-3-5-sonnet-latest';\n\n      try {\n        // Check if this is a reflection schema request (has specific format)\n        const isReflection = params.schema?.facts && params.schema.relationships;\n\n        // Build a prompt that asks for JSON output\n        let jsonPrompt = params.prompt;\n\n        // Don't modify the prompt if it already contains explicit JSON formatting instructions\n        if (!jsonPrompt.includes('```json') && !jsonPrompt.includes('respond with valid JSON')) {\n          jsonPrompt +=\n            '\\nPlease respond with valid JSON only, without any explanations, markdown formatting, or additional text.';\n        }\n\n        let systemPrompt = runtime.character.system\n          ? `${runtime.character.system}\\nYou must respond with valid JSON only.`\n          : 'You must respond with valid JSON only.';\n\n        // For reflection schemas, we need a more specific instruction\n        if (isReflection) {\n          systemPrompt +=\n            \" Ensure your response includes 'thought', 'facts', and 'relationships' properties exactly as specified in the prompt.\";\n        } else {\n          systemPrompt += ' No markdown, no code blocks, no explanation text.';\n        }\n\n        // Generate text response that should contain JSON\n        const { text } = await generateText({\n          model: anthropic(largeModel),\n          prompt: jsonPrompt,\n          system: systemPrompt,\n          temperature: params.temperature || 0.2, // Lower temperature for more predictable structured output\n        });\n\n        // Extract and parse JSON from the response with our improved function\n        try {\n          logger.debug('Attempting to parse response from Anthropic model');\n          const jsonObject = extractAndParseJSON(text);\n\n          // Ensure reflection schema has all required properties\n          const processedObject = ensureReflectionProperties(jsonObject, isReflection);\n\n          return processedObject;\n        } catch (parseError) {\n          logger.error(`Failed to parse JSON from Anthropic response: ${parseError}`);\n          logger.error(`Raw response: ${text}`);\n          throw new Error('Invalid JSON returned from Anthropic model');\n        }\n      } catch (error) {\n        logger.error(`Error generating object: ${error}`);\n        throw error;\n      }\n    },\n  },\n  tests: [\n    {\n      name: 'anthropic_plugin_tests',\n      tests: [\n        {\n          name: 'anthropic_test_text_small',\n          fn: async (runtime) => {\n            try {\n              const text = await runtime.useModel(ModelType.TEXT_SMALL, {\n                prompt: 'What is the nature of reality in 10 words?',\n              });\n              if (text.length === 0) {\n                throw new Error('Failed to generate text');\n              }\n              logger.log(`generated with test_text_small: ${text}`);\n            } catch (error) {\n              logger.error(`Error in test_text_small: ${error}`);\n              throw error;\n            }\n          },\n        },\n        {\n          name: 'anthropic_test_text_large',\n          fn: async (runtime) => {\n            try {\n              const text = await runtime.useModel(ModelType.TEXT_LARGE, {\n                prompt: 'What is the nature of reality in 10 words?',\n              });\n              if (text.length === 0) {\n                throw new Error('Failed to generate text');\n              }\n              logger.log(`generated with test_text_large: ${text}`);\n            } catch (error) {\n              logger.error(`Error in test_text_large: ${error}`);\n              throw error;\n            }\n          },\n        },\n        {\n          name: 'anthropic_test_object_with_code_blocks',\n          fn: async (runtime) => {\n            try {\n              const result = await runtime.useModel(ModelType.OBJECT_SMALL, {\n                prompt: 'Give me instructions to install Node.js',\n                schema: { type: 'object' },\n              });\n              logger.log(`Generated object with code blocks: ${JSON.stringify(result)}`);\n              if (!result || result.error) {\n                throw new Error('Failed to generate object with code blocks');\n              }\n            } catch (error) {\n              logger.error(`Error in test_object_with_code_blocks: ${error}`);\n              throw error;\n            }\n          },\n        },\n      ],\n    },\n  ],\n};\n\nexport default anthropicPlugin;\n","import { logger } from '@elizaos/core';\nimport { jsonrepair } from 'jsonrepair';\n\n/**\n * Type definition for a code block placeholder\n */\ninterface CodeBlockPlaceholder {\n  placeholder: string;\n  content: string;\n}\n\n/**\n * Type for reconstructed response\n */\nexport interface ReconstructedResponse {\n  type: 'reconstructed_response';\n  thought?: string;\n  message?: string;\n  codeBlocks?: Array<{\n    language: string;\n    code: string;\n  }>;\n}\n\n/**\n * Type for reflection schema response\n */\nexport interface ReflectionResponse {\n  thought: string;\n  facts: unknown[];\n  relationships: unknown[];\n  rawContent: string;\n}\n\n/**\n * Type for unstructured response\n */\nexport interface UnstructuredResponse {\n  type: 'unstructured_response';\n  content: string;\n}\n\n/**\n * Type for JSON extraction result\n */\nexport type ExtractedJSON =\n  | Record<string, unknown>\n  | ReconstructedResponse\n  | ReflectionResponse\n  | UnstructuredResponse;\n\n/**\n * Helper function to ensure reflection response has all required properties\n */\nexport const ensureReflectionProperties = (\n  obj: ExtractedJSON,\n  isReflection: boolean\n): ExtractedJSON => {\n  // Only process if it's a reflection schema request\n  if (!isReflection) return obj;\n\n  // Check if it's an object with potentially missing reflection properties\n  if (obj !== null && typeof obj === 'object') {\n    // Create a new object with required properties\n    return {\n      ...obj,\n      thought: 'thought' in obj ? obj.thought || '' : '',\n      facts: 'facts' in obj ? obj.facts || [] : [],\n      relationships: 'relationships' in obj ? obj.relationships || [] : [],\n    };\n  }\n\n  return obj;\n};\n\n/**\n * Enhanced function to extract and parse JSON from LLM responses\n * Handles various response formats including mixed markdown and JSON with code blocks\n */\nexport const extractAndParseJSON = (text: string): ExtractedJSON => {\n  try {\n    // First attempt: Try direct JSON parsing\n    return JSON.parse(text);\n  } catch (initialError) {\n    logger.debug('Initial JSON parse failed, attempting alternative extraction methods');\n\n    // Try JSONRepair first\n    try {\n      const repaired = jsonrepair(text);\n      return JSON.parse(repaired);\n    } catch (repairError) {\n      logger.debug('JSONRepair failed, proceeding with manual extraction methods');\n    }\n\n    // Check if we have a valid JSON structure with embedded code blocks\n    // This specifically addresses the case where Anthropic returns a valid JSON object\n    // that contains markdown code blocks inside string values\n    const isJsonWithCodeBlocks =\n      text.trim().startsWith('{') && text.trim().endsWith('}') && text.includes('```');\n\n    if (isJsonWithCodeBlocks) {\n      // Replace code blocks with escaped versions to preserve them in the JSON\n      try {\n        // First, try to preserve the code blocks by temporarily replacing them\n        const codeBlockPlaceholders: CodeBlockPlaceholder[] = [];\n        let placeholderCounter = 0;\n        const textWithPlaceholders = text.replace(\n          /```(\\w*)\\n([\\s\\S]*?)```/g,\n          (match, language, code) => {\n            const placeholder = `__CODE_BLOCK_${placeholderCounter++}__`;\n            codeBlockPlaceholders.push({\n              placeholder,\n              content: `\\`\\`\\`${language}\\n${code}\\`\\`\\``,\n            });\n            return placeholder;\n          }\n        );\n\n        // Try parsing with placeholders\n        let parsed: Record<string, unknown>;\n        try {\n          // Try JSONRepair first\n          const repaired = jsonrepair(textWithPlaceholders);\n          parsed = JSON.parse(repaired);\n        } catch (e) {\n          // If JSONRepair fails, try direct parsing\n          parsed = JSON.parse(textWithPlaceholders);\n        }\n\n        // Restore code blocks in the parsed object\n        const restoreCodeBlocks = (obj: unknown): unknown => {\n          if (typeof obj === 'string') {\n            let result = obj;\n            for (const { placeholder, content } of codeBlockPlaceholders) {\n              result = result.replace(placeholder, content);\n            }\n            return result;\n          } else if (Array.isArray(obj)) {\n            return obj.map((item) => restoreCodeBlocks(item));\n          } else if (obj !== null && typeof obj === 'object') {\n            const result: Record<string, unknown> = {};\n            for (const [key, value] of Object.entries(obj as Record<string, unknown>)) {\n              result[key] = restoreCodeBlocks(value);\n            }\n            return result;\n          }\n          return obj;\n        };\n\n        return restoreCodeBlocks(parsed) as ExtractedJSON;\n      } catch (codeBlockError) {\n        logger.debug('Code block preservation failed, continuing with other methods');\n      }\n    }\n\n    // Try to extract JSON from code blocks\n    const extractFromCodeBlocks = (text: string): string | null => {\n      // First priority: explicit JSON code blocks\n      const jsonBlockRegex = /```json\\s*([\\s\\S]*?)\\s*```/;\n      const jsonMatch = text.match(jsonBlockRegex);\n      if (jsonMatch && jsonMatch[1]) {\n        return jsonMatch[1].trim();\n      }\n\n      // Second priority: any code block that contains JSON-like content\n      const anyBlockRegex = /```(?:\\w*)\\s*([\\s\\S]*?)\\s*```/g;\n      let match;\n      while ((match = anyBlockRegex.exec(text)) !== null) {\n        const blockContent = match[1].trim();\n        if (blockContent.startsWith('{') && blockContent.endsWith('}')) {\n          return blockContent;\n        }\n      }\n\n      return null;\n    };\n\n    const extractedFromCodeBlock = extractFromCodeBlocks(text);\n    if (extractedFromCodeBlock) {\n      try {\n        // Try parsing the extracted content\n        return JSON.parse(extractedFromCodeBlock);\n      } catch (blockParseError) {\n        try {\n          // Try with JSONRepair\n          const repaired = jsonrepair(extractedFromCodeBlock);\n          return JSON.parse(repaired);\n        } catch (blockRepairError) {\n          logger.debug('Failed to parse JSON from code block after repair');\n        }\n      }\n    }\n\n    // Look for JSON structure outside of code blocks\n    const extractJSON = (text: string): string | null => {\n      // Try to find JSON-like content in the text\n      // This regex looks for content that starts with { and ends with }\n      const jsonContentRegex = /(^|\\n)\\s*(\\{[\\s\\S]*\\})\\s*($|\\n)/;\n      const contentMatch = text.match(jsonContentRegex);\n\n      if (contentMatch && contentMatch[2]) {\n        return contentMatch[2].trim();\n      }\n\n      // If no direct match, try to find the largest JSON-like structure\n      const jsonPattern = /\\{[\\s\\S]*?\\}/g;\n      const jsonMatches = text.match(jsonPattern);\n\n      if (jsonMatches && jsonMatches.length > 0) {\n        // Sort matches by length (descending) to try the largest JSON-like structure first\n        return [...jsonMatches].sort((a, b) => b.length - a.length)[0];\n      }\n\n      return null;\n    };\n\n    const extractedJSON = extractJSON(text);\n    if (extractedJSON) {\n      try {\n        // Try parsing the extracted JSON\n        return JSON.parse(extractedJSON);\n      } catch (extractParseError) {\n        try {\n          // Try with JSONRepair\n          const repaired = jsonrepair(extractedJSON);\n          return JSON.parse(repaired);\n        } catch (extractRepairError) {\n          logger.debug('Failed to parse JSON after extraction and repair');\n        }\n      }\n    }\n\n    // Try to manually extract a \"thought\"/\"message\" structure which is common\n    const manuallyExtractStructure = (\n      text: string\n    ): ReconstructedResponse | ReflectionResponse | null => {\n      // Extract thought/message pattern if present\n      const thoughtPattern = /\"thought\"\\s*:\\s*\"([^\"]*?)(?:\"|$)/;\n      const messagePattern = /\"message\"\\s*:\\s*\"([^\"]*?)(?:\"|$)/;\n\n      const thoughtMatch = text.match(thoughtPattern);\n      const messageMatch = text.match(messagePattern);\n\n      if (thoughtMatch || messageMatch) {\n        const extractedContent: ReconstructedResponse = {\n          type: 'reconstructed_response',\n        };\n\n        if (thoughtMatch) {\n          extractedContent.thought = thoughtMatch[1].replace(/\\\\n/g, '\\n');\n        }\n\n        if (messageMatch) {\n          extractedContent.message = messageMatch[1].replace(/\\\\n/g, '\\n');\n        } else {\n          // If no message was found but we have a thought, try to use the rest of the content as message\n          let remainingContent = text;\n          if (thoughtMatch) {\n            // Remove the thought part from the content\n            remainingContent = remainingContent.replace(thoughtPattern, '');\n          }\n\n          // Look for code blocks in the remaining content\n          const codeBlocks: Array<{ language: string; code: string }> = [];\n          const codeBlockRegex = /```([\\w]*)\\n([\\s\\S]*?)```/g;\n          let match;\n\n          while ((match = codeBlockRegex.exec(remainingContent)) !== null) {\n            codeBlocks.push({\n              language: match[1] || 'text',\n              code: match[2].trim(),\n            });\n          }\n\n          if (codeBlocks.length > 0) {\n            extractedContent.codeBlocks = codeBlocks;\n            // Remove code blocks from the remaining content\n            remainingContent = remainingContent.replace(codeBlockRegex, '');\n          }\n\n          // Use the cleaned remaining content as message\n          extractedContent.message = remainingContent.trim();\n        }\n\n        return extractedContent;\n      }\n\n      // For reflection schema-like structure\n      if (text.includes('thought') || text.includes('facts') || text.includes('relationships')) {\n        logger.debug('Attempting to extract reflection schema components');\n\n        const result: ReflectionResponse = {\n          thought: '',\n          facts: [],\n          relationships: [],\n          rawContent: text,\n        };\n\n        // Try to extract thought\n        const thoughtMatch = text.match(/thought[\"\\s:]+([^\"{}[\\],]+)/i);\n        if (thoughtMatch) {\n          result.thought = thoughtMatch[1].trim();\n        }\n\n        // Attempt to extract facts and relationships would go here\n        // This would require more complex parsing logic for arrays\n\n        return result;\n      }\n\n      return null;\n    };\n\n    const manuallyExtracted = manuallyExtractStructure(text);\n    if (manuallyExtracted) {\n      return manuallyExtracted;\n    }\n\n    // Last resort: Return a structured object with the raw text\n    logger.debug(\n      'All JSON extraction methods failed, returning structured object with raw content'\n    );\n    return {\n      type: 'unstructured_response',\n      content: text,\n    };\n  }\n};\n\n// Future config schema for generateObject\n/**\n * Configuration schema for Anthropic plugin.\n * This will be used when we switch to generateObject instead of generateText.\n */\nexport const configSchemaComment = `\n// Define a configuration schema for the Anthropics plugin.\n// const configSchema = z.object({\n// \tANTHROPIC_API_KEY: z.string().min(1, \"Anthropic API key is required\"),\n// \tANTHROPIC_SMALL_MODEL: z.string().optional(),\n// \tANTHROPIC_LARGE_MODEL: z.string().optional(),\n// });\n`;\n"],"mappings":"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","names":["logger","text","thoughtMatch","logger"]}