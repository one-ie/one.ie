{"version":3,"sources":["../src/index.ts","../src/init.ts","../src/utils/config.ts","../src/models/text.ts","../src/providers/openrouter.ts","../src/utils/events.ts","../src/utils/helpers.ts","../src/models/object.ts","../src/models/image.ts","../src/utils/image-storage.ts"],"sourcesContent":["import {\n\tModelType,\n\ttype Plugin,\n\ttype IAgentRuntime,\n\ttype GenerateTextParams,\n\ttype ObjectGenerationParams,\n\ttype ImageDescriptionParams,\n\ttype ImageGenerationParams,\n} from \"@elizaos/core\";\nimport type { Tool, ToolChoice } from \"ai\";\nimport { initializeOpenRouter } from \"./init\";\nimport { handleTextSmall, handleTextLarge } from \"./models/text\";\nimport { handleObjectSmall, handleObjectLarge } from \"./models/object\";\nimport { handleImageDescription, handleImageGeneration } from \"./models/image\";\n\n/**\n * Defines the OpenRouter plugin with its name, description, and configuration options.\n * @type {Plugin}\n */\nexport const openrouterPlugin: Plugin = {\n\tname: \"openrouter\",\n\tdescription: \"OpenRouter plugin\",\n\tconfig: {\n\t\tOPENROUTER_API_KEY: process.env.OPENROUTER_API_KEY,\n\t\tOPENROUTER_BASE_URL: process.env.OPENROUTER_BASE_URL,\n\t\tOPENROUTER_SMALL_MODEL: process.env.OPENROUTER_SMALL_MODEL,\n\t\tOPENROUTER_LARGE_MODEL: process.env.OPENROUTER_LARGE_MODEL,\n\t\tOPENROUTER_IMAGE_MODEL: process.env.OPENROUTER_IMAGE_MODEL,\n\t\tOPENROUTER_IMAGE_GENERATION_MODEL: process.env.OPENROUTER_IMAGE_GENERATION_MODEL,\n\t\tOPENROUTER_AUTO_CLEANUP_IMAGES: process.env.OPENROUTER_AUTO_CLEANUP_IMAGES,\n\t\tSMALL_MODEL: process.env.SMALL_MODEL,\n\t\tLARGE_MODEL: process.env.LARGE_MODEL,\n\t\tIMAGE_MODEL: process.env.IMAGE_MODEL,\n\t\tIMAGE_GENERATION_MODEL: process.env.IMAGE_GENERATION_MODEL,\n\t},\n\tasync init(config, runtime) {\n\t\t// Note: We intentionally don't await here because ElizaOS expects\n\t\t// the init method to return quickly. The initializeOpenRouter function\n\t\t// only performs synchronous validation and logging, so it's safe to\n\t\t// call without await. This prevents blocking the plugin initialization.\n\t\tinitializeOpenRouter(config, runtime);\n\t},\n\tmodels: {\n\t\t[ModelType.TEXT_SMALL]: async (\n\t\t\truntime: IAgentRuntime,\n\t\t\tparams: GenerateTextParams & {\n\t\t\t\ttools?: Record<string, Tool>;\n\t\t\t\ttoolChoice?: ToolChoice<Record<string, Tool>>;\n\t\t\t},\n\t\t) => {\n\t\t\treturn handleTextSmall(runtime, params);\n\t\t},\n\t\t[ModelType.TEXT_LARGE]: async (\n\t\t\truntime: IAgentRuntime,\n\t\t\tparams: GenerateTextParams & {\n\t\t\t\ttools?: Record<string, Tool>;\n\t\t\t\ttoolChoice?: ToolChoice<Record<string, Tool>>;\n\t\t\t},\n\t\t) => {\n\t\t\treturn handleTextLarge(runtime, params);\n\t\t},\n\t\t[ModelType.OBJECT_SMALL]: async (\n\t\t\truntime: IAgentRuntime,\n\t\t\tparams: ObjectGenerationParams,\n\t\t) => {\n\t\t\treturn handleObjectSmall(runtime, params);\n\t\t},\n\t\t[ModelType.OBJECT_LARGE]: async (\n\t\t\truntime: IAgentRuntime,\n\t\t\tparams: ObjectGenerationParams,\n\t\t) => {\n\t\t\treturn handleObjectLarge(runtime, params);\n\t\t},\n\t\t[ModelType.IMAGE_DESCRIPTION]: async (\n\t\t\truntime: IAgentRuntime,\n\t\t\tparams: ImageDescriptionParams | string,\n\t\t) => {\n\t\t\treturn handleImageDescription(runtime, params);\n\t\t},\n\t\t[ModelType.IMAGE]: async (\n\t\t\truntime: IAgentRuntime,\n\t\t\tparams: ImageGenerationParams,\n\t\t) => {\n\t\t\treturn handleImageGeneration(runtime, params);\n\t\t},\n\t},\n};\n\nexport default openrouterPlugin;\n","import { logger, type IAgentRuntime } from \"@elizaos/core\";\nimport { fetch } from \"undici\";\nimport { getApiKey, getBaseURL } from \"./utils/config\";\n\n/**\n * Initialize and validate OpenRouter configuration\n * Returns the exact same function that works inline\n */\nexport function initializeOpenRouter(_config: any, runtime: IAgentRuntime) {\n\t// do check in the background\n\t(async () => {\n\t\ttry {\n\t\t\tif (!getApiKey(runtime)) {\n\t\t\t\tlogger.warn(\n\t\t\t\t\t\"OPENROUTER_API_KEY is not set in environment - OpenRouter functionality will be limited\",\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tconst baseURL = getBaseURL(runtime);\n\t\t\t\tconst response = await fetch(`${baseURL}/models`, {\n\t\t\t\t\theaders: { Authorization: `Bearer ${getApiKey(runtime)}` },\n\t\t\t\t});\n\t\t\t\tif (!response.ok) {\n\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t`OpenRouter API key validation failed: ${response.statusText}`,\n\t\t\t\t\t);\n\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t\"OpenRouter functionality will be limited until a valid API key is provided\",\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tlogger.log(\"OpenRouter API key validated successfully\");\n\t\t\t\t}\n\t\t\t} catch (fetchError: unknown) {\n\t\t\t\tconst message =\n\t\t\t\t\tfetchError instanceof Error ? fetchError.message : String(fetchError);\n\t\t\t\tlogger.warn(`Error validating OpenRouter API key: ${message}`);\n\t\t\t\tlogger.warn(\n\t\t\t\t\t\"OpenRouter functionality will be limited until a valid API key is provided\",\n\t\t\t\t);\n\t\t\t}\n\t\t} catch (error: unknown) {\n\t\t\tconst message =\n\t\t\t\t(error as { errors?: Array<{ message: string }> })?.errors\n\t\t\t\t\t?.map((e) => e.message)\n\t\t\t\t\t.join(\", \") ||\n\t\t\t\t(error instanceof Error ? error.message : String(error));\n\t\t\tlogger.warn(\n\t\t\t\t`OpenRouter plugin configuration issue: ${message} - You need to configure the OPENROUTER_API_KEY in your environment variables`,\n\t\t\t);\n\t\t}\n\t})();\n\treturn;\n}\n","import type { IAgentRuntime } from \"@elizaos/core\";\n\n/**\n * Retrieves a configuration setting from the runtime, falling back to environment variables or a default value if not found.\n *\n * @param key - The name of the setting to retrieve.\n * @param defaultValue - The value to return if the setting is not found in the runtime or environment.\n * @returns The resolved setting value, or {@link defaultValue} if not found.\n */\nexport function getSetting(\n\truntime: IAgentRuntime,\n\tkey: string,\n\tdefaultValue?: string,\n): string | undefined {\n\treturn runtime.getSetting(key) ?? process.env[key] ?? defaultValue;\n}\n\n/**\n * Retrieves the OpenRouter API base URL from runtime settings, environment variables, or defaults.\n *\n * @returns The resolved base URL for OpenRouter API requests.\n */\nexport function getBaseURL(runtime: IAgentRuntime): string {\n\treturn (\n\t\tgetSetting(\n\t\t\truntime,\n\t\t\t\"OPENROUTER_BASE_URL\",\n\t\t\t\"https://openrouter.ai/api/v1\",\n\t\t) || \"https://openrouter.ai/api/v1\"\n\t);\n}\n\n/**\n * Helper function to get the API key for OpenRouter\n *\n * @param runtime The runtime context\n * @returns The configured API key\n */\nexport function getApiKey(runtime: IAgentRuntime): string | undefined {\n\treturn getSetting(runtime, \"OPENROUTER_API_KEY\");\n}\n\n/**\n * Helper function to get the small model name with fallbacks\n *\n * @param runtime The runtime context\n * @returns The configured small model name\n */\nexport function getSmallModel(runtime: IAgentRuntime): string {\n\treturn (\n\t\tgetSetting(runtime, \"OPENROUTER_SMALL_MODEL\") ??\n\t\tgetSetting(runtime, \"SMALL_MODEL\", \"google/gemini-2.0-flash-001\") ??\n\t\t\"google/gemini-2.0-flash-001\"\n\t);\n}\n\n/**\n * Helper function to get the large model name with fallbacks\n *\n * @param runtime The runtime context\n * @returns The configured large model name\n */\nexport function getLargeModel(runtime: IAgentRuntime): string {\n  return (\n    getSetting(runtime, \"OPENROUTER_LARGE_MODEL\") ??\n    getSetting(\n      runtime,\n      \"LARGE_MODEL\",\n      \"google/gemini-2.5-flash\",\n    ) ??\n    \"google/gemini-2.5-flash\"\n  );\n}\n\n/**\n * Helper function to get the image model name with fallbacks\n *\n * @param runtime The runtime context\n * @returns The configured image model name\n */\nexport function getImageModel(runtime: IAgentRuntime): string {\n\treturn (\n\t\tgetSetting(runtime, \"OPENROUTER_IMAGE_MODEL\") ??\n\t\tgetSetting(runtime, \"IMAGE_MODEL\", \"x-ai/grok-2-vision-1212\") ??\n\t\t\"x-ai/grok-2-vision-1212\"\n\t);\n}\n\n/**\n * Helper function to get the image generation model name with fallbacks\n *\n * @param runtime The runtime context\n * @returns The configured image generation model name\n */\nexport function getImageGenerationModel(runtime: IAgentRuntime): string {\n\treturn (\n\t\tgetSetting(runtime, \"OPENROUTER_IMAGE_GENERATION_MODEL\") ??\n\t\tgetSetting(runtime, \"IMAGE_GENERATION_MODEL\", \"google/gemini-2.5-flash-image-preview\") ??\n\t\t\"google/gemini-2.5-flash-image-preview\"\n\t);\n}\n\n/**\n * Helper function to check if auto cleanup is enabled for generated images\n *\n * @param runtime The runtime context\n * @returns Whether to auto-cleanup generated images (default: false)\n */\nexport function shouldAutoCleanupImages(runtime: IAgentRuntime): boolean {\n\tconst setting = getSetting(runtime, \"OPENROUTER_AUTO_CLEANUP_IMAGES\", \"false\");\n\treturn setting?.toLowerCase() === \"true\";\n}\n","import type { GenerateTextParams, IAgentRuntime } from \"@elizaos/core\";\nimport { logger, ModelType } from \"@elizaos/core\";\nimport { generateText } from \"ai\";\nimport type { Tool, ToolChoice } from \"ai\";\n\nimport { createOpenRouterProvider } from \"../providers\";\nimport type { ToolCall, ToolResponse, ToolResult } from \"../types\";\nimport { getSmallModel, getLargeModel } from \"../utils/config\";\nimport { emitModelUsageEvent } from \"../utils/events\";\nimport { handleEmptyToolResponse, decodeBase64Fields } from \"../utils/helpers\";\n\n/**\n * Common text generation logic for both small and large models\n */\nasync function generateTextWithModel(\n\truntime: IAgentRuntime,\n\tmodelType: typeof ModelType.TEXT_SMALL | typeof ModelType.TEXT_LARGE,\n\tparams: GenerateTextParams & {\n\t\ttools?: Record<string, Tool>;\n\t\ttoolChoice?: ToolChoice<Record<string, Tool>>;\n\t},\n): Promise<string | ToolResponse> {\n\tconst { prompt, stopSequences = [], tools, toolChoice } = params;\n\tconst temperature = params.temperature ?? 0.7;\n\tconst frequencyPenalty = params.frequencyPenalty ?? 0.7;\n\tconst presencePenalty = params.presencePenalty ?? 0.7;\n\tconst maxResponseLength = params.maxTokens ?? 8192;\n\n\tconst openrouter = createOpenRouterProvider(runtime);\n\tconst modelName =\n\t\tmodelType === ModelType.TEXT_SMALL\n\t\t\t? getSmallModel(runtime)\n\t\t\t: getLargeModel(runtime);\n\tconst modelLabel =\n\t\tmodelType === ModelType.TEXT_SMALL ? \"TEXT_SMALL\" : \"TEXT_LARGE\";\n\n\tlogger.log(\n\t\t`[OpenRouter] Generating text with ${modelLabel} model: ${modelName}`,\n\t);\n\n\tconst generateParams: Parameters<typeof generateText>[0] & {\n\t\textra_body?: { provider?: { require_parameters?: boolean } };\n\t} = {\n\t\tmodel: openrouter.chat(modelName),\n\t\tprompt: prompt,\n\t\tsystem: runtime.character.system ?? undefined,\n\t\ttemperature: temperature,\n\t\tmaxTokens: maxResponseLength,\n\t\tfrequencyPenalty: frequencyPenalty,\n\t\tpresencePenalty: presencePenalty,\n\t\tstopSequences: stopSequences,\n\t};\n\n\t// Add tools if provided\n\tif (tools) {\n\t\tgenerateParams.tools = tools;\n\t\tgenerateParams.maxSteps = 10; // Allow tool call + response generation\n\t\t// For OpenRouter: ensure request is only routed to providers that support function calling\n\t\tgenerateParams.extra_body = {\n\t\t\tprovider: {\n\t\t\t\trequire_parameters: true,\n\t\t\t},\n\t\t};\n\t}\n\n\t// Add toolChoice if provided\n\tif (toolChoice) {\n\t\tgenerateParams.toolChoice = toolChoice;\n\t}\n\n\t// Capture tool results if tools are used\n\tlet capturedToolResults: ToolResult[] = [];\n\tlet capturedToolCalls: ToolCall[] = [];\n\n\tif (tools) {\n\t\tgenerateParams.onStepFinish = async (stepResult) => {\n\t\t\tif (stepResult.toolCalls && stepResult.toolCalls.length > 0) {\n\t\t\t\tcapturedToolCalls = [...capturedToolCalls, ...stepResult.toolCalls];\n\t\t\t}\n\t\t\tif (stepResult.toolResults && stepResult.toolResults.length > 0) {\n\t\t\t\t// Decode base64 fields in tool results before capturing them\n\t\t\t\tconst decodedToolResults = stepResult.toolResults.map((result: ToolResult) => ({\n\t\t\t\t\t...result,\n\t\t\t\t\tresult: decodeBase64Fields(result.result),\n\t\t\t\t}));\n\t\t\t\tcapturedToolResults = [...capturedToolResults, ...decodedToolResults];\n\t\t\t}\n\t\t};\n\t}\n\n\tconst response = await generateText(generateParams);\n\n\t// Handle cases where tool execution doesn't generate text\n\tlet responseText: string;\n\tif (\n\t\ttools &&\n\t\t(!response.text ||\n\t\t\tresponse.text.trim() === \"\" ||\n\t\t\tresponse.text === \"Tools executed successfully.\")\n\t) {\n\t\tresponseText = handleEmptyToolResponse(modelLabel);\n\t} else {\n\t\tresponseText = response.text;\n\t}\n\n\tif (response.usage) {\n\t\temitModelUsageEvent(runtime, modelType, prompt, response.usage);\n\t}\n\n\t// If tools were used, return the full response object to access toolCalls and toolResults\n\tif (\n\t\ttools &&\n\t\t(capturedToolCalls.length > 0 || capturedToolResults.length > 0)\n\t) {\n\t\treturn {\n\t\t\ttext: responseText,\n\t\t\ttoolCalls: capturedToolCalls,\n\t\t\ttoolResults: capturedToolResults,\n\t\t\t// Include other useful properties\n\t\t\tusage: response.usage,\n\t\t\tfinishReason: response.finishReason,\n\t\t};\n\t}\n\n\treturn responseText;\n}\n\n/**\n * TEXT_SMALL model handler\n */\nexport async function handleTextSmall(\n\truntime: IAgentRuntime,\n\tparams: GenerateTextParams & {\n\t\ttools?: Record<string, Tool>;\n\t\ttoolChoice?: ToolChoice<Record<string, Tool>>;\n\t},\n): Promise<string | ToolResponse> {\n\treturn generateTextWithModel(runtime, ModelType.TEXT_SMALL, params);\n}\n\n/**\n * TEXT_LARGE model handler\n */\nexport async function handleTextLarge(\n\truntime: IAgentRuntime,\n\tparams: GenerateTextParams & {\n\t\ttools?: Record<string, Tool>;\n\t\ttoolChoice?: ToolChoice<Record<string, Tool>>;\n\t},\n): Promise<string | ToolResponse> {\n\treturn generateTextWithModel(runtime, ModelType.TEXT_LARGE, params);\n}\n","import { createOpenRouter } from \"@openrouter/ai-sdk-provider\";\nimport { logger, type IAgentRuntime } from \"@elizaos/core\";\nimport { getApiKey } from \"../utils/config\";\n\n/**\n * Create an OpenRouter provider instance with proper configuration\n *\n * @param runtime The runtime context\n * @returns Configured OpenRouter provider instance\n */\nexport function createOpenRouterProvider(runtime: IAgentRuntime) {\n\tconst apiKey = getApiKey(runtime);\n\tif (!apiKey) {\n\t\t// This case should ideally be caught in init, but good practice to check\n\t\tlogger.error(\n\t\t\t\"OpenRouter API Key is missing when trying to create provider\",\n\t\t);\n\t\tthrow new Error(\"OpenRouter API Key is missing.\");\n\t}\n\n\t// Note: createOpenRouter doesn't seem to take baseURL directly in the documentation.\n\t// It might pick it up from OPENROUTER_BASE_URL env var automatically,\n\t// or it might not be needed/configurable in the same way as createOpenRouter.\n\t// We'll rely on the apiKey for now.\n\treturn createOpenRouter({\n\t\tapiKey: apiKey,\n\t\t// We might need to handle baseURL differently if required.\n\t\t// The @ai-sdk/provider utils might handle OPENROUTER_BASE_URL env var.\n\t});\n}\n","import {\n\tEventType,\n\ttype IAgentRuntime,\n\ttype ModelTypeName,\n} from \"@elizaos/core\";\nimport type { LanguageModelUsage } from \"ai\";\n\n/**\n * Emits a model usage event\n */\nexport function emitModelUsageEvent(\n\truntime: IAgentRuntime,\n\ttype: ModelTypeName,\n\tprompt: string,\n\tusage: LanguageModelUsage,\n) {\n\truntime.emitEvent(EventType.MODEL_USED, {\n\t\tprovider: \"openrouter\",\n\t\ttype,\n\t\tprompt,\n\t\ttokens: {\n\t\t\tprompt: usage.promptTokens,\n\t\t\tcompletion: usage.completionTokens,\n\t\t\ttotal: usage.totalTokens,\n\t\t},\n\t});\n}\n","import { logger } from \"@elizaos/core\";\nimport { JSONParseError } from \"ai\";\nimport type { GenerateTextResponse, ImageDescriptionResult } from \"../types\";\n\n/**\n * Returns a function to repair JSON text\n */\nexport function getJsonRepairFunction(): (params: {\n\ttext: string;\n\terror: unknown;\n}) => Promise<string | null> {\n\treturn async ({ text, error }: { text: string; error: unknown }) => {\n\t\ttry {\n\t\t\tif (error instanceof JSONParseError) {\n\t\t\t\tconst cleanedText = text.replace(/```json\\n|\\n```|```/g, \"\");\n\t\t\t\tJSON.parse(cleanedText);\n\t\t\t\treturn cleanedText;\n\t\t\t}\n\t\t\treturn null;\n\t\t} catch (jsonError: unknown) {\n\t\t\tconst message =\n\t\t\t\tjsonError instanceof Error ? jsonError.message : String(jsonError);\n\t\t\tlogger.warn(`Failed to repair JSON text: ${message}`);\n\t\t\treturn null;\n\t\t}\n\t};\n}\n\n// Re-export for backward compatibility\nexport { emitModelUsageEvent } from \"./events\";\n\n/**\n * Logs response structure for debugging (debug level only)\n */\nexport function logResponseStructure(\n\tmodelType: string,\n\tresponse: GenerateTextResponse,\n) {\n\tlogger.debug(`[${modelType}] Response structure: ${JSON.stringify({\n\t\thasText: !!response.text,\n\t\ttextLength: response.text?.length || 0,\n\t\thasSteps: !!response.steps,\n\t\tstepsCount: response.steps?.length || 0,\n\t\tfinishReason: response.finishReason,\n\t\tusage: response.usage,\n\t}, null, 2)}`);\n}\n\n/**\n * Handles cases where tool execution doesn't generate text\n */\nexport function handleEmptyToolResponse(modelType: string): string {\n\tlogger.warn(`[${modelType}] No text generated after tool execution`);\n\n\tconst fallbackText =\n\t\t\"I executed the requested action. The tool completed successfully.\";\n\tlogger.warn(`[${modelType}] Using fallback response text`);\n\treturn fallbackText;\n}\n\n/**\n * Parses image description response from text or JSON format\n */\nexport function parseImageDescriptionResponse(\n\tresponseText: string,\n): ImageDescriptionResult {\n\t// Try to parse as JSON first\n\ttry {\n\t\tconst jsonResponse = JSON.parse(responseText);\n\t\tif (jsonResponse.title && jsonResponse.description) {\n\t\t\treturn jsonResponse;\n\t\t}\n\t} catch (e) {\n\t\t// If not valid JSON, process as text\n\t\tlogger.debug(`Parsing as JSON failed, processing as text: ${e}`);\n\t}\n\n\t// Extract title and description from text format\n\tconst titleMatch = responseText.match(/title[:\\s]+(.+?)(?:\\n|$)/i);\n\tconst title = titleMatch?.[1]?.trim() || \"Image Analysis\";\n\tconst description = responseText\n\t\t.replace(/title[:\\s]+(.+?)(?:\\n|$)/i, \"\")\n\t\t.trim();\n\n\treturn { title, description };\n}\n\n/**\n * Handles errors during object generation, including JSON repair attempts\n */\nexport async function handleObjectGenerationError(\n\terror: unknown,\n): Promise<unknown> {\n\tif (error instanceof JSONParseError) {\n\t\tlogger.error(`[generateObject] Failed to parse JSON: ${error.message}`);\n\t\tconst repairFunction = getJsonRepairFunction();\n\t\tconst repairedJsonString = await repairFunction({\n\t\t\ttext: error.text,\n\t\t\terror,\n\t\t});\n\n\t\tif (repairedJsonString) {\n\t\t\ttry {\n\t\t\t\tconst repairedObject = JSON.parse(repairedJsonString);\n\t\t\t\tlogger.log(\"[generateObject] Successfully repaired JSON.\");\n\t\t\t\treturn repairedObject;\n\t\t\t} catch (repairParseError: unknown) {\n\t\t\t\tconst message =\n\t\t\t\t\trepairParseError instanceof Error\n\t\t\t\t\t\t? repairParseError.message\n\t\t\t\t\t\t: String(repairParseError);\n\t\t\t\tlogger.error(\n\t\t\t\t\t`[generateObject] Failed to parse repaired JSON: ${message}`,\n\t\t\t\t);\n\t\t\t\tif (repairParseError instanceof Error) throw repairParseError;\n\t\t\t\tthrow Object.assign(new Error(message), { cause: repairParseError });\n\t\t\t}\n\t\t} else {\n\t\t\tlogger.error(\"[generateObject] JSON repair failed.\");\n\t\t\tthrow error;\n\t\t}\n\t} else {\n\t\tconst message = error instanceof Error ? error.message : String(error);\n\t\tlogger.error(`[generateObject] Unknown error: ${message}`);\n\t\tif (error instanceof Error) throw error;\n\t\tthrow Object.assign(new Error(message), { cause: error });\n\t}\n}\n\n/**\n * Quick heuristic to detect if a field likely contains base64 data\n */\nfunction isLikelyBase64(key: string, value: string): boolean {\n\t// Check key name patterns (expanded base64 field names)\n\tconst base64KeyPattern = /^(data|content|body|payload|encoded|b64|base64|document)$/i;\n\tif (!base64KeyPattern.test(key)) return false;\n\t\n\t// Basic format checks\n\tif (value.length < 20 || value.length > 1024 * 1024) return false; // Size limits\n\tif (value.length % 4 !== 0) return false; // Invalid base64 length\n\tif (!/^[A-Za-z0-9+/]*={0,2}$/.test(value)) return false; // Invalid chars\n\t\n\treturn true;\n}\n\n/**\n * Recursively decodes base64 fields in tool results\n */\nexport function decodeBase64Fields(obj: unknown, depth = 0): unknown {\n\t// Simple depth protection\n\tif (depth > 5) return obj;\n\tif (!obj || typeof obj !== \"object\") return obj;\n\tif (Array.isArray(obj)) return obj.map(item => decodeBase64Fields(item, depth + 1));\n\t\n\tconst decoded: Record<string, unknown> = {};\n\tfor (const [key, value] of Object.entries(obj)) {\n\t\tif (typeof value === \"string\" && isLikelyBase64(key, value)) {\n\t\t\ttry {\n\t\t\t\tdecoded[key] = Buffer.from(value, \"base64\").toString(\"utf8\");\n\t\t\t\tlogger.debug(`[decodeBase64] Decoded field '${key}' (${value.length} chars)`);\n\t\t\t} catch (error) {\n\t\t\t\tlogger.warn(`[decodeBase64] Failed to decode field '${key}': ${error}`);\n\t\t\t\tdecoded[key] = value; // Keep original if decode fails\n\t\t\t}\n\t\t} else if (value && typeof value === \"object\") {\n\t\t\tdecoded[key] = decodeBase64Fields(value, depth + 1);\n\t\t} else {\n\t\t\tdecoded[key] = value;\n\t\t}\n\t}\n\treturn decoded;\n}\n","import {\n\tModelType,\n\tlogger,\n\ttype IAgentRuntime,\n\ttype ObjectGenerationParams,\n} from \"@elizaos/core\";\nimport { generateObject } from \"ai\";\nimport { createOpenRouterProvider } from \"../providers\";\nimport { getSmallModel, getLargeModel } from \"../utils/config\";\nimport { emitModelUsageEvent } from \"../utils/events\";\nimport {\n\tgetJsonRepairFunction,\n\thandleObjectGenerationError,\n} from \"../utils/helpers\";\n\n/**\n * Common object generation logic for both small and large models\n */\nasync function generateObjectWithModel(\n\truntime: IAgentRuntime,\n\tmodelType: typeof ModelType.OBJECT_SMALL | typeof ModelType.OBJECT_LARGE,\n\tparams: ObjectGenerationParams,\n): Promise<unknown> {\n\tconst openrouter = createOpenRouterProvider(runtime);\n\tconst modelName =\n\t\tmodelType === ModelType.OBJECT_SMALL\n\t\t\t? getSmallModel(runtime)\n\t\t\t: getLargeModel(runtime);\n\tconst modelLabel =\n\t\tmodelType === ModelType.OBJECT_SMALL ? \"OBJECT_SMALL\" : \"OBJECT_LARGE\";\n\n\tlogger.log(`[OpenRouter] Using ${modelLabel} model: ${modelName}`);\n\tconst temperature = params.temperature ?? 0.7;\n\n\ttry {\n\t\tconst { object, usage } = await generateObject({\n\t\t\tmodel: openrouter.chat(modelName),\n\t\t\toutput: \"no-schema\",\n\t\t\tprompt: params.prompt,\n\t\t\ttemperature: temperature,\n\t\t\texperimental_repairText: getJsonRepairFunction(),\n\t\t});\n\n\t\tif (usage) {\n\t\t\temitModelUsageEvent(runtime, modelType, params.prompt, usage);\n\t\t}\n\t\treturn object;\n\t} catch (error: unknown) {\n\t\treturn handleObjectGenerationError(error);\n\t}\n}\n\n/**\n * OBJECT_SMALL model handler\n */\nexport async function handleObjectSmall(\n\truntime: IAgentRuntime,\n\tparams: ObjectGenerationParams,\n): Promise<unknown> {\n\treturn generateObjectWithModel(runtime, ModelType.OBJECT_SMALL, params);\n}\n\n/**\n * OBJECT_LARGE model handler\n */\nexport async function handleObjectLarge(\n\truntime: IAgentRuntime,\n\tparams: ObjectGenerationParams,\n): Promise<unknown> {\n\treturn generateObjectWithModel(runtime, ModelType.OBJECT_LARGE, params);\n}\n","import {\n\tlogger,\n\ttype IAgentRuntime,\n\ttype ImageDescriptionParams,\n\ttype ImageGenerationParams,\n} from \"@elizaos/core\";\nimport { generateText } from \"ai\";\nimport type { OpenRouterImageResponse } from \"../types\";\nimport { createOpenRouterProvider } from \"../providers\";\nimport { getApiKey, getBaseURL, getImageGenerationModel, getImageModel, shouldAutoCleanupImages } from \"../utils/config\";\nimport { parseImageDescriptionResponse } from \"../utils/helpers\";\nimport { deleteImage, saveBase64Image } from \"../utils/image-storage\";\n\n/**\n * IMAGE_DESCRIPTION model handler\n */\nexport async function handleImageDescription(\n\truntime: IAgentRuntime,\n\tparams: ImageDescriptionParams | string,\n): Promise<{ title: string; description: string }> {\n\tlet imageUrl: string;\n\tlet promptText: string | undefined;\n\tconst modelName = getImageModel(runtime);\n\tlogger.log(`[OpenRouter] Using IMAGE_DESCRIPTION model: ${modelName}`);\n\tconst maxTokens = 300;\n\n\tif (typeof params === \"string\") {\n\t\timageUrl = params;\n\t\tpromptText =\n\t\t\t\"Please analyze this image and provide a title and detailed description.\";\n\t} else {\n\t\timageUrl = params.imageUrl;\n\t\tpromptText =\n\t\t\tparams.prompt ||\n\t\t\t\"Please analyze this image and provide a title and detailed description.\";\n\t}\n\n\tconst openrouter = createOpenRouterProvider(runtime);\n\n\tconst messages = [\n\t\t{\n\t\t\trole: \"user\" as const,\n\t\t\tcontent: [\n\t\t\t\t{ type: \"text\" as const, text: promptText },\n\t\t\t\t{ type: \"image\" as const, image: imageUrl },\n\t\t\t],\n\t\t},\n\t];\n\n\ttry {\n\t\tconst model = openrouter.chat(modelName);\n\n\t\tconst { text: responseText } = await generateText({\n\t\t\tmodel: model,\n\t\t\tmessages: messages,\n\t\t\tmaxTokens: maxTokens,\n\t\t});\n\n\t\treturn parseImageDescriptionResponse(responseText);\n\t} catch (error: unknown) {\n\t\tconst message = error instanceof Error ? error.message : String(error);\n\t\tlogger.error(`Error analyzing image: ${message}`);\n\t\treturn {\n\t\t\ttitle: \"Failed to analyze image\",\n\t\t\tdescription: `Error: ${message}`,\n\t\t};\n\t}\n}\n\n/**\n * IMAGE model handler for image generation\n */\nexport async function handleImageGeneration(\n\truntime: IAgentRuntime,\n\tparams: ImageGenerationParams,\n): Promise<{ url: string }[]> {\n\tconst modelName = getImageGenerationModel(runtime);\n\tlogger.log(`[OpenRouter] Using IMAGE_GENERATION model: ${modelName}`);\n\tconst apiKey = getApiKey(runtime);\n\n\ttry {\n\t\tif (!apiKey) {\n\t\t\tlogger.error(\"[OpenRouter] OpenRouter API key is missing\");\n\t\t\treturn [];\n\t\t}\n\t\tconst baseUrl = getBaseURL(runtime);\n\t\tconst response = await fetch(`${baseUrl}/chat/completions`, {\n\t\t\tmethod: 'POST',\n\t\t\theaders: {\n\t\t\t\tAuthorization: `Bearer ${apiKey}`,\n\t\t\t\t'Content-Type': 'application/json',\n\t\t\t},\n\t\t\tbody: JSON.stringify({\n\t\t\t\tmodel: modelName,\n\t\t\t\tmessages: [\n\t\t\t\t\t{\n\t\t\t\t\t\trole: 'user',\n\t\t\t\t\t\tcontent: params.prompt,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tmodalities: ['image', 'text'],\n\t\t\t}),\n\t\t\t// 60 seconds timeout\n\t\t\tsignal: AbortSignal.timeout ? AbortSignal.timeout(60000) : undefined,\n\t\t});\n\n\t\tif (!response.ok) {\n\t\t\tconst errorText = await response.text().catch(() => \"\");\n\t\t\tthrow new Error(`HTTP ${response.status} ${response.statusText} ${errorText}`);\n\t\t}\n\n\t\tconst result = await response.json() as OpenRouterImageResponse;\n\t\t\n\t\tconst images: { url: string; filepath?: string }[] = [];\n\t\tconst savedPaths: string[] = [];\n\n\t\t// Extract images from the response\n\t\tif (result.choices?.[0]?.message?.images) {\n\t\t\tfor (const [index, image] of result.choices[0].message.images.entries()) {\n\t\t\t\tconst base64Url = image.image_url.url;\n\t\t\t\t\n\t\t\t\t// Save image to disk\n\t\t\t\tconst filepath = await saveBase64Image(base64Url, runtime.agentId, index);\n\t\t\t\tif (filepath) {\n\t\t\t\t\t// Return the actual file path for Discord/Telegram compatibility\n\t\t\t\t\tlogger.log(`[OpenRouter] Returning image with filepath: ${filepath}`);\n\t\t\t\t\timages.push({ \n\t\t\t\t\t\turl: filepath  // Use actual file path\n\t\t\t\t\t});\n\t\t\t\t\tsavedPaths.push(filepath);\n\t\t\t\t} else if (!base64Url.startsWith('data:')) {\n\t\t\t\t\t// If not base64, return as is (might be a URL)\n\t\t\t\t\timages.push({ url: base64Url });\n\t\t\t\t} else {\n\t\t\t\t\t// Failed to save base64 image\n\t\t\t\t\tlogger.warn(`[OpenRouter] Failed to save image ${index + 1}, skipping`);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Clean up images after a short delay if auto-cleanup is enabled\n\t\tif (savedPaths.length > 0 && shouldAutoCleanupImages(runtime)) {\n\t\t\tsetTimeout(() => {\n\t\t\t\tsavedPaths.forEach(path => {\n\t\t\t\t\tdeleteImage(path);\n\t\t\t\t});\n\t\t\t}, 30000); // Delete after 30 seconds\n\t\t}\n\n\t\tif (images.length === 0) {\n\t\t\tthrow new Error(\"No images generated in response\");\n\t\t}\n\n\t\tlogger.log(`[OpenRouter] Generated ${images.length} image(s)`);\n\t\treturn images;\n\t} catch (error: unknown) {\n\t\tconst message = error instanceof Error ? error.message : String(error);\n\t\tlogger.error(`[OpenRouter] Error generating image: ${message}`);\n\t\treturn [];\n\t}\n}\n","import { existsSync, unlinkSync } from \"node:fs\";\nimport { mkdir, writeFile } from \"node:fs/promises\";\nimport { join } from \"node:path\";\nimport { logger, getGeneratedDir } from \"@elizaos/core\";\n\n/**\n * Save base64 image to disk and return the file path\n */\nexport async function saveBase64Image(base64Url: string, agentId: string, index: number = 0): Promise<string | null> {\n\t// Extract base64 data and extension with MIME type validation\n\tconst m = base64Url.match(/^data:(image\\/[a-zA-Z0-9.+-]+);base64,([A-Za-z0-9+/=]+)$/);\n\tif (!m) return null;\n\t\n\tconst mime = m[1];\n\tconst base64Data = m[2];\n\t\n\t// Whitelist of allowed MIME types mapped to extensions\n\tconst extMap: Record<string, string> = {\n\t\t\"image/png\": \"png\",\n\t\t\"image/jpeg\": \"jpg\",\n\t\t\"image/jpg\": \"jpg\",\n\t\t\"image/webp\": \"webp\",\n\t\t\"image/gif\": \"gif\",\n\t\t\"image/bmp\": \"bmp\",\n\t\t\"image/tiff\": \"tiff\"\n\t};\n\t\n\tconst extension = extMap[mime];\n\tif (!extension) return null;\n\n\t// Use ElizaOS convention: .eliza/data/generated/{agentId}/\n\tconst baseDir = join(getGeneratedDir(), agentId);\n\t\n\t// Create directory if it doesn't exist\n\tif (!existsSync(baseDir)) {\n\t\tawait mkdir(baseDir, { recursive: true });\n\t}\n\n\t// Generate filename with timestamp\n\tconst timestamp = Date.now();\n\tconst filename = `image_${timestamp}_${index}.${extension}`;\n\tconst filepath = join(baseDir, filename);\n\n\t// Save image to disk\n\tconst buffer = Buffer.from(base64Data, \"base64\");\n\tawait writeFile(filepath, buffer);\n\n\tlogger.info(`[OpenRouter] Saved generated image to ${filepath}`);\n\n\t// Return only the file path for Discord/Telegram to read\n\treturn filepath;\n}\n\n/**\n * Delete a specific image file\n */\nexport function deleteImage(filepath: string): void {\n\ttry {\n\t\tif (existsSync(filepath)) {\n\t\t\tunlinkSync(filepath);\n\t\t\tlogger.debug(`[OpenRouter] Deleted image: ${filepath}`);\n\t\t}\n\t} catch (error) {\n\t\tlogger.warn(`[OpenRouter] Failed to delete image ${filepath}:`, String(error));\n\t}\n}"],"mappings":"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","names":["ModelType","fetch","fetch","logger","logger","logger","logger","logger","logger","ModelType","logger","ModelType","logger","logger","generateText","logger","logger","generateText","ModelType"]}