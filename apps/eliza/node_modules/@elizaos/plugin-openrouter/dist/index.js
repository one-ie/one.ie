// src/index.ts
import {
  ModelType as ModelType3
} from "@elizaos/core";

// src/init.ts
import { logger } from "@elizaos/core";
import { fetch as fetch2 } from "undici";

// src/utils/config.ts
function getSetting(runtime, key, defaultValue) {
  return runtime.getSetting(key) ?? process.env[key] ?? defaultValue;
}
function getBaseURL(runtime) {
  return getSetting(
    runtime,
    "OPENROUTER_BASE_URL",
    "https://openrouter.ai/api/v1"
  ) || "https://openrouter.ai/api/v1";
}
function getApiKey(runtime) {
  return getSetting(runtime, "OPENROUTER_API_KEY");
}
function getSmallModel(runtime) {
  return getSetting(runtime, "OPENROUTER_SMALL_MODEL") ?? getSetting(runtime, "SMALL_MODEL", "google/gemini-2.0-flash-001") ?? "google/gemini-2.0-flash-001";
}
function getLargeModel(runtime) {
  return getSetting(runtime, "OPENROUTER_LARGE_MODEL") ?? getSetting(
    runtime,
    "LARGE_MODEL",
    "google/gemini-2.5-flash"
  ) ?? "google/gemini-2.5-flash";
}
function getImageModel(runtime) {
  return getSetting(runtime, "OPENROUTER_IMAGE_MODEL") ?? getSetting(runtime, "IMAGE_MODEL", "x-ai/grok-2-vision-1212") ?? "x-ai/grok-2-vision-1212";
}
function getImageGenerationModel(runtime) {
  return getSetting(runtime, "OPENROUTER_IMAGE_GENERATION_MODEL") ?? getSetting(runtime, "IMAGE_GENERATION_MODEL", "google/gemini-2.5-flash-image-preview") ?? "google/gemini-2.5-flash-image-preview";
}
function shouldAutoCleanupImages(runtime) {
  const setting = getSetting(runtime, "OPENROUTER_AUTO_CLEANUP_IMAGES", "false");
  return setting?.toLowerCase() === "true";
}

// src/init.ts
function initializeOpenRouter(_config, runtime) {
  (async () => {
    try {
      if (!getApiKey(runtime)) {
        logger.warn(
          "OPENROUTER_API_KEY is not set in environment - OpenRouter functionality will be limited"
        );
        return;
      }
      try {
        const baseURL = getBaseURL(runtime);
        const response = await fetch2(`${baseURL}/models`, {
          headers: { Authorization: `Bearer ${getApiKey(runtime)}` }
        });
        if (!response.ok) {
          logger.warn(
            `OpenRouter API key validation failed: ${response.statusText}`
          );
          logger.warn(
            "OpenRouter functionality will be limited until a valid API key is provided"
          );
        } else {
          logger.log("OpenRouter API key validated successfully");
        }
      } catch (fetchError) {
        const message = fetchError instanceof Error ? fetchError.message : String(fetchError);
        logger.warn(`Error validating OpenRouter API key: ${message}`);
        logger.warn(
          "OpenRouter functionality will be limited until a valid API key is provided"
        );
      }
    } catch (error) {
      const message = error?.errors?.map((e) => e.message).join(", ") || (error instanceof Error ? error.message : String(error));
      logger.warn(
        `OpenRouter plugin configuration issue: ${message} - You need to configure the OPENROUTER_API_KEY in your environment variables`
      );
    }
  })();
  return;
}

// src/models/text.ts
import { logger as logger4, ModelType } from "@elizaos/core";
import { generateText } from "ai";

// src/providers/openrouter.ts
import { createOpenRouter } from "@openrouter/ai-sdk-provider";
import { logger as logger2 } from "@elizaos/core";
function createOpenRouterProvider(runtime) {
  const apiKey = getApiKey(runtime);
  if (!apiKey) {
    logger2.error(
      "OpenRouter API Key is missing when trying to create provider"
    );
    throw new Error("OpenRouter API Key is missing.");
  }
  return createOpenRouter({
    apiKey
    // We might need to handle baseURL differently if required.
    // The @ai-sdk/provider utils might handle OPENROUTER_BASE_URL env var.
  });
}

// src/utils/events.ts
import {
  EventType
} from "@elizaos/core";
function emitModelUsageEvent(runtime, type, prompt, usage) {
  runtime.emitEvent(EventType.MODEL_USED, {
    provider: "openrouter",
    type,
    prompt,
    tokens: {
      prompt: usage.promptTokens,
      completion: usage.completionTokens,
      total: usage.totalTokens
    }
  });
}

// src/utils/helpers.ts
import { logger as logger3 } from "@elizaos/core";
import { JSONParseError } from "ai";
function getJsonRepairFunction() {
  return async ({ text, error }) => {
    try {
      if (error instanceof JSONParseError) {
        const cleanedText = text.replace(/```json\n|\n```|```/g, "");
        JSON.parse(cleanedText);
        return cleanedText;
      }
      return null;
    } catch (jsonError) {
      const message = jsonError instanceof Error ? jsonError.message : String(jsonError);
      logger3.warn(`Failed to repair JSON text: ${message}`);
      return null;
    }
  };
}
function handleEmptyToolResponse(modelType) {
  logger3.warn(`[${modelType}] No text generated after tool execution`);
  const fallbackText = "I executed the requested action. The tool completed successfully.";
  logger3.warn(`[${modelType}] Using fallback response text`);
  return fallbackText;
}
function parseImageDescriptionResponse(responseText) {
  try {
    const jsonResponse = JSON.parse(responseText);
    if (jsonResponse.title && jsonResponse.description) {
      return jsonResponse;
    }
  } catch (e) {
    logger3.debug(`Parsing as JSON failed, processing as text: ${e}`);
  }
  const titleMatch = responseText.match(/title[:\s]+(.+?)(?:\n|$)/i);
  const title = titleMatch?.[1]?.trim() || "Image Analysis";
  const description = responseText.replace(/title[:\s]+(.+?)(?:\n|$)/i, "").trim();
  return { title, description };
}
async function handleObjectGenerationError(error) {
  if (error instanceof JSONParseError) {
    logger3.error(`[generateObject] Failed to parse JSON: ${error.message}`);
    const repairFunction = getJsonRepairFunction();
    const repairedJsonString = await repairFunction({
      text: error.text,
      error
    });
    if (repairedJsonString) {
      try {
        const repairedObject = JSON.parse(repairedJsonString);
        logger3.log("[generateObject] Successfully repaired JSON.");
        return repairedObject;
      } catch (repairParseError) {
        const message = repairParseError instanceof Error ? repairParseError.message : String(repairParseError);
        logger3.error(
          `[generateObject] Failed to parse repaired JSON: ${message}`
        );
        if (repairParseError instanceof Error) throw repairParseError;
        throw Object.assign(new Error(message), { cause: repairParseError });
      }
    } else {
      logger3.error("[generateObject] JSON repair failed.");
      throw error;
    }
  } else {
    const message = error instanceof Error ? error.message : String(error);
    logger3.error(`[generateObject] Unknown error: ${message}`);
    if (error instanceof Error) throw error;
    throw Object.assign(new Error(message), { cause: error });
  }
}
function isLikelyBase64(key, value) {
  const base64KeyPattern = /^(data|content|body|payload|encoded|b64|base64|document)$/i;
  if (!base64KeyPattern.test(key)) return false;
  if (value.length < 20 || value.length > 1024 * 1024) return false;
  if (value.length % 4 !== 0) return false;
  if (!/^[A-Za-z0-9+/]*={0,2}$/.test(value)) return false;
  return true;
}
function decodeBase64Fields(obj, depth = 0) {
  if (depth > 5) return obj;
  if (!obj || typeof obj !== "object") return obj;
  if (Array.isArray(obj)) return obj.map((item) => decodeBase64Fields(item, depth + 1));
  const decoded = {};
  for (const [key, value] of Object.entries(obj)) {
    if (typeof value === "string" && isLikelyBase64(key, value)) {
      try {
        decoded[key] = Buffer.from(value, "base64").toString("utf8");
        logger3.debug(`[decodeBase64] Decoded field '${key}' (${value.length} chars)`);
      } catch (error) {
        logger3.warn(`[decodeBase64] Failed to decode field '${key}': ${error}`);
        decoded[key] = value;
      }
    } else if (value && typeof value === "object") {
      decoded[key] = decodeBase64Fields(value, depth + 1);
    } else {
      decoded[key] = value;
    }
  }
  return decoded;
}

// src/models/text.ts
async function generateTextWithModel(runtime, modelType, params) {
  const { prompt, stopSequences = [], tools, toolChoice } = params;
  const temperature = params.temperature ?? 0.7;
  const frequencyPenalty = params.frequencyPenalty ?? 0.7;
  const presencePenalty = params.presencePenalty ?? 0.7;
  const maxResponseLength = params.maxTokens ?? 8192;
  const openrouter = createOpenRouterProvider(runtime);
  const modelName = modelType === ModelType.TEXT_SMALL ? getSmallModel(runtime) : getLargeModel(runtime);
  const modelLabel = modelType === ModelType.TEXT_SMALL ? "TEXT_SMALL" : "TEXT_LARGE";
  logger4.log(
    `[OpenRouter] Generating text with ${modelLabel} model: ${modelName}`
  );
  const generateParams = {
    model: openrouter.chat(modelName),
    prompt,
    system: runtime.character.system ?? void 0,
    temperature,
    maxTokens: maxResponseLength,
    frequencyPenalty,
    presencePenalty,
    stopSequences
  };
  if (tools) {
    generateParams.tools = tools;
    generateParams.maxSteps = 10;
    generateParams.extra_body = {
      provider: {
        require_parameters: true
      }
    };
  }
  if (toolChoice) {
    generateParams.toolChoice = toolChoice;
  }
  let capturedToolResults = [];
  let capturedToolCalls = [];
  if (tools) {
    generateParams.onStepFinish = async (stepResult) => {
      if (stepResult.toolCalls && stepResult.toolCalls.length > 0) {
        capturedToolCalls = [...capturedToolCalls, ...stepResult.toolCalls];
      }
      if (stepResult.toolResults && stepResult.toolResults.length > 0) {
        const decodedToolResults = stepResult.toolResults.map((result) => ({
          ...result,
          result: decodeBase64Fields(result.result)
        }));
        capturedToolResults = [...capturedToolResults, ...decodedToolResults];
      }
    };
  }
  const response = await generateText(generateParams);
  let responseText;
  if (tools && (!response.text || response.text.trim() === "" || response.text === "Tools executed successfully.")) {
    responseText = handleEmptyToolResponse(modelLabel);
  } else {
    responseText = response.text;
  }
  if (response.usage) {
    emitModelUsageEvent(runtime, modelType, prompt, response.usage);
  }
  if (tools && (capturedToolCalls.length > 0 || capturedToolResults.length > 0)) {
    return {
      text: responseText,
      toolCalls: capturedToolCalls,
      toolResults: capturedToolResults,
      // Include other useful properties
      usage: response.usage,
      finishReason: response.finishReason
    };
  }
  return responseText;
}
async function handleTextSmall(runtime, params) {
  return generateTextWithModel(runtime, ModelType.TEXT_SMALL, params);
}
async function handleTextLarge(runtime, params) {
  return generateTextWithModel(runtime, ModelType.TEXT_LARGE, params);
}

// src/models/object.ts
import {
  ModelType as ModelType2,
  logger as logger5
} from "@elizaos/core";
import { generateObject } from "ai";
async function generateObjectWithModel(runtime, modelType, params) {
  const openrouter = createOpenRouterProvider(runtime);
  const modelName = modelType === ModelType2.OBJECT_SMALL ? getSmallModel(runtime) : getLargeModel(runtime);
  const modelLabel = modelType === ModelType2.OBJECT_SMALL ? "OBJECT_SMALL" : "OBJECT_LARGE";
  logger5.log(`[OpenRouter] Using ${modelLabel} model: ${modelName}`);
  const temperature = params.temperature ?? 0.7;
  try {
    const { object, usage } = await generateObject({
      model: openrouter.chat(modelName),
      output: "no-schema",
      prompt: params.prompt,
      temperature,
      experimental_repairText: getJsonRepairFunction()
    });
    if (usage) {
      emitModelUsageEvent(runtime, modelType, params.prompt, usage);
    }
    return object;
  } catch (error) {
    return handleObjectGenerationError(error);
  }
}
async function handleObjectSmall(runtime, params) {
  return generateObjectWithModel(runtime, ModelType2.OBJECT_SMALL, params);
}
async function handleObjectLarge(runtime, params) {
  return generateObjectWithModel(runtime, ModelType2.OBJECT_LARGE, params);
}

// src/models/image.ts
import {
  logger as logger7
} from "@elizaos/core";
import { generateText as generateText2 } from "ai";

// src/utils/image-storage.ts
import { existsSync, unlinkSync } from "node:fs";
import { mkdir, writeFile } from "node:fs/promises";
import { join } from "node:path";
import { logger as logger6, getGeneratedDir } from "@elizaos/core";
async function saveBase64Image(base64Url, agentId, index = 0) {
  const m = base64Url.match(/^data:(image\/[a-zA-Z0-9.+-]+);base64,([A-Za-z0-9+/=]+)$/);
  if (!m) return null;
  const mime = m[1];
  const base64Data = m[2];
  const extMap = {
    "image/png": "png",
    "image/jpeg": "jpg",
    "image/jpg": "jpg",
    "image/webp": "webp",
    "image/gif": "gif",
    "image/bmp": "bmp",
    "image/tiff": "tiff"
  };
  const extension = extMap[mime];
  if (!extension) return null;
  const baseDir = join(getGeneratedDir(), agentId);
  if (!existsSync(baseDir)) {
    await mkdir(baseDir, { recursive: true });
  }
  const timestamp = Date.now();
  const filename = `image_${timestamp}_${index}.${extension}`;
  const filepath = join(baseDir, filename);
  const buffer = Buffer.from(base64Data, "base64");
  await writeFile(filepath, buffer);
  logger6.info(`[OpenRouter] Saved generated image to ${filepath}`);
  return filepath;
}
function deleteImage(filepath) {
  try {
    if (existsSync(filepath)) {
      unlinkSync(filepath);
      logger6.debug(`[OpenRouter] Deleted image: ${filepath}`);
    }
  } catch (error) {
    logger6.warn(`[OpenRouter] Failed to delete image ${filepath}:`, String(error));
  }
}

// src/models/image.ts
async function handleImageDescription(runtime, params) {
  let imageUrl;
  let promptText;
  const modelName = getImageModel(runtime);
  logger7.log(`[OpenRouter] Using IMAGE_DESCRIPTION model: ${modelName}`);
  const maxTokens = 300;
  if (typeof params === "string") {
    imageUrl = params;
    promptText = "Please analyze this image and provide a title and detailed description.";
  } else {
    imageUrl = params.imageUrl;
    promptText = params.prompt || "Please analyze this image and provide a title and detailed description.";
  }
  const openrouter = createOpenRouterProvider(runtime);
  const messages = [
    {
      role: "user",
      content: [
        { type: "text", text: promptText },
        { type: "image", image: imageUrl }
      ]
    }
  ];
  try {
    const model = openrouter.chat(modelName);
    const { text: responseText } = await generateText2({
      model,
      messages,
      maxTokens
    });
    return parseImageDescriptionResponse(responseText);
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    logger7.error(`Error analyzing image: ${message}`);
    return {
      title: "Failed to analyze image",
      description: `Error: ${message}`
    };
  }
}
async function handleImageGeneration(runtime, params) {
  const modelName = getImageGenerationModel(runtime);
  logger7.log(`[OpenRouter] Using IMAGE_GENERATION model: ${modelName}`);
  const apiKey = getApiKey(runtime);
  try {
    if (!apiKey) {
      logger7.error("[OpenRouter] OpenRouter API key is missing");
      return [];
    }
    const baseUrl = getBaseURL(runtime);
    const response = await fetch(`${baseUrl}/chat/completions`, {
      method: "POST",
      headers: {
        Authorization: `Bearer ${apiKey}`,
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        model: modelName,
        messages: [
          {
            role: "user",
            content: params.prompt
          }
        ],
        modalities: ["image", "text"]
      }),
      // 60 seconds timeout
      signal: AbortSignal.timeout ? AbortSignal.timeout(6e4) : void 0
    });
    if (!response.ok) {
      const errorText = await response.text().catch(() => "");
      throw new Error(`HTTP ${response.status} ${response.statusText} ${errorText}`);
    }
    const result = await response.json();
    const images = [];
    const savedPaths = [];
    if (result.choices?.[0]?.message?.images) {
      for (const [index, image] of result.choices[0].message.images.entries()) {
        const base64Url = image.image_url.url;
        const filepath = await saveBase64Image(base64Url, runtime.agentId, index);
        if (filepath) {
          logger7.log(`[OpenRouter] Returning image with filepath: ${filepath}`);
          images.push({
            url: filepath
            // Use actual file path
          });
          savedPaths.push(filepath);
        } else if (!base64Url.startsWith("data:")) {
          images.push({ url: base64Url });
        } else {
          logger7.warn(`[OpenRouter] Failed to save image ${index + 1}, skipping`);
        }
      }
    }
    if (savedPaths.length > 0 && shouldAutoCleanupImages(runtime)) {
      setTimeout(() => {
        savedPaths.forEach((path) => {
          deleteImage(path);
        });
      }, 3e4);
    }
    if (images.length === 0) {
      throw new Error("No images generated in response");
    }
    logger7.log(`[OpenRouter] Generated ${images.length} image(s)`);
    return images;
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    logger7.error(`[OpenRouter] Error generating image: ${message}`);
    return [];
  }
}

// src/index.ts
var openrouterPlugin = {
  name: "openrouter",
  description: "OpenRouter plugin",
  config: {
    OPENROUTER_API_KEY: process.env.OPENROUTER_API_KEY,
    OPENROUTER_BASE_URL: process.env.OPENROUTER_BASE_URL,
    OPENROUTER_SMALL_MODEL: process.env.OPENROUTER_SMALL_MODEL,
    OPENROUTER_LARGE_MODEL: process.env.OPENROUTER_LARGE_MODEL,
    OPENROUTER_IMAGE_MODEL: process.env.OPENROUTER_IMAGE_MODEL,
    OPENROUTER_IMAGE_GENERATION_MODEL: process.env.OPENROUTER_IMAGE_GENERATION_MODEL,
    OPENROUTER_AUTO_CLEANUP_IMAGES: process.env.OPENROUTER_AUTO_CLEANUP_IMAGES,
    SMALL_MODEL: process.env.SMALL_MODEL,
    LARGE_MODEL: process.env.LARGE_MODEL,
    IMAGE_MODEL: process.env.IMAGE_MODEL,
    IMAGE_GENERATION_MODEL: process.env.IMAGE_GENERATION_MODEL
  },
  async init(config, runtime) {
    initializeOpenRouter(config, runtime);
  },
  models: {
    [ModelType3.TEXT_SMALL]: async (runtime, params) => {
      return handleTextSmall(runtime, params);
    },
    [ModelType3.TEXT_LARGE]: async (runtime, params) => {
      return handleTextLarge(runtime, params);
    },
    [ModelType3.OBJECT_SMALL]: async (runtime, params) => {
      return handleObjectSmall(runtime, params);
    },
    [ModelType3.OBJECT_LARGE]: async (runtime, params) => {
      return handleObjectLarge(runtime, params);
    },
    [ModelType3.IMAGE_DESCRIPTION]: async (runtime, params) => {
      return handleImageDescription(runtime, params);
    },
    [ModelType3.IMAGE]: async (runtime, params) => {
      return handleImageGeneration(runtime, params);
    }
  }
};
var index_default = openrouterPlugin;
export {
  index_default as default,
  openrouterPlugin
};
//# sourceMappingURL=index.js.map